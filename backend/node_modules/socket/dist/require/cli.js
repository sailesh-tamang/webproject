#!/usr/bin/env node
'use strict';

function _socketInterop(e) {
  let c = 0
  for (const k in e ?? {}) {
    c = c === 0 && k === 'default' ? 1 : 0
    if (!c && k !== '__esModule') break
  }
  return c ? e.default : e
}

var process$1 = require('node:process');
var require$$0 = require('node:url');
var ponyCause = _socketInterop(require('pony-cause'));
var vendor = require('./vendor.js');
var colors = _socketInterop(require('yoctocolors-cjs'));
var micromatch = _socketInterop(require('micromatch'));
var simpleGit = _socketInterop(require('simple-git'));
var sdk = require('@socketsecurity/sdk');
var events = require('node:events');
var fs = require('node:fs');
var path = require('node:path');
var ndjson = _socketInterop(require('ndjson'));
var index = require('./index.js');
var objects = require('@socketsecurity/registry/lib/objects');
var fs$1 = require('node:fs/promises');
var ScreenWidget = _socketInterop(require('blessed/lib/widgets/screen'));
var contrib = _socketInterop(require('blessed-contrib'));
var spinner = require('@socketsecurity/registry/lib/spinner');
var constants = require('./constants.js');
var prompts = require('@socketsecurity/registry/lib/prompts');
var yargsParse = _socketInterop(require('yargs-parser'));
var words = require('@socketsecurity/registry/lib/words');
var npm = require('@socketsecurity/registry/lib/npm');
var chalkTable = _socketInterop(require('chalk-table'));
var require$$0$1 = require('node:util');
var registry = require('@socketsecurity/registry');
var packages = require('@socketsecurity/registry/lib/packages');
var registryConstants = require('@socketsecurity/registry/lib/constants');
var isInteractive = require('@socketregistry/is-interactive/index.cjs');
var terminalLink = _socketInterop(require('terminal-link'));
var spawn = _socketInterop(require('@npmcli/promise-spawn'));
var npa = _socketInterop(require('npm-package-arg'));
var semver = _socketInterop(require('semver'));
var tinyglobby = _socketInterop(require('tinyglobby'));
var promises = require('@socketsecurity/registry/lib/promises');
var browserslist = _socketInterop(require('browserslist'));
var which = _socketInterop(require('which'));
var index_cjs = require('@socketregistry/hyrious__bun.lockb/index.cjs');
var sorts = require('@socketsecurity/registry/lib/sorts');
var strings = require('@socketsecurity/registry/lib/strings');
var yaml = _socketInterop(require('yaml'));
var regexps = require('@socketsecurity/registry/lib/regexps');
var npm$1 = require('./npm.js');
var npmPaths = require('./npm-paths.js');
var betterAjvErrors = _socketInterop(require('@apideck/better-ajv-errors'));
var config$A = require('@socketsecurity/config');
var readline = require('node:readline/promises');
var TableWidget = _socketInterop(require('blessed-contrib/lib/widget/table'));
var os = require('node:os');
var readline$1 = require('node:readline');

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/core/classes.py

class Comment {
  id = 0;
  body = '';
  body_list = [];
  constructor(arg) {
    this.id = arg.id ?? this.id;
    this.body = arg.body ?? this.body;
    this.body_list = arg.body_list ?? this.body_list;
  }
}
class Diff {
  newPackages = [];
  newCapabilities = {};
  removedPackages = [];
  newAlerts = [];
  id = '';
  sbom = '';
  packages = {};
  reportUrl = '';
  diffUrl = '';
}
class FullScan {
  id = '';
  created_at = '';
  updated_at = '';
  organizationId = '';
  repositoryId = '';
  branch = '';
  commit_message = '';
  commit_hash = '';
  pull_request = 0;
  sbom_artifacts = [];
  packages = {};
  constructor(obj = {}) {
    this.id = obj.id ?? this.id;
    this.created_at = obj.created_at ?? this.created_at;
    this.updated_at = obj.updated_at ?? this.updated_at;
    this.organizationId = obj.organizationId ?? this.organizationId;
    this.repositoryId = obj.repositoryId ?? this.repositoryId;
    this.branch = obj.branch ?? this.branch;
    this.commit_message = obj.commit_message ?? this.commit_message;
    this.commit_hash = obj.commit_hash ?? this.commit_hash;
    this.pull_request = obj.pull_request ?? this.pull_request;
    this.sbom_artifacts = obj.sbom_artifacts ?? this.sbom_artifacts;
    this.packages = obj.packages ?? this.packages;
  }
}
class Issue {
  pkg_type = '';
  pkg_name = '';
  pkg_version = '';
  category = '';
  type = '';
  severity = '';
  pkg_id = '';
  props = {};
  key = '';
  error = false;
  warn = false;
  ignore = false;
  monitor = false;
  description = '';
  title = '';
  emoji = '';
  next_step_title = '';
  suggestion = '';
  introduced_by = [];
  manifests = '';
  url = '';
  purl = '';
  constructor(arg) {
    this.pkg_type = arg.pkg_type ?? this.pkg_type;
    this.pkg_name = arg.pkg_name ?? this.pkg_name;
    this.pkg_version = arg.pkg_version ?? this.pkg_version;
    this.type = arg.type ?? this.type;
    this.severity = arg.severity ?? this.severity;
    this.pkg_id = arg.pkg_id ?? this.pkg_id;
    this.props = arg.props ?? this.props;
    this.key = arg.key ?? this.key;
    this.error = arg.error ?? this.error;
    this.warn = arg.warn ?? this.warn;
    this.ignore = arg.ignore ?? this.ignore;
    this.monitor = arg.monitor ?? this.monitor;
    this.description = arg.description ?? this.description;
    this.title = arg.title ?? this.title;
    this.next_step_title = arg.next_step_title ?? this.next_step_title;
    this.suggestion = arg.suggestion ?? this.suggestion;
    if (arg.introduced_by) {
      const arr = [];
      for (const item of arg.introduced_by) {
        const [, manifest] = item;
        arr.push(manifest);
      }
      this.manifests = arr.join(';');
    }
  }
}
class Package {
  type = '';
  name = '';
  version = '';
  release = '';
  id = '';
  direct = false;
  manifestFiles = [];
  author = [];
  size = 0;
  scores = {};
  alerts = [];
  alert_counts = {};
  topLevelAncestors = [];
  url = '';
  transitives = 0;
  license = 'NoLicenseFound';
  license_text = '';
  purl = '';
  constructor(arg) {
    this.type = arg.type ?? this.type;
    this.name = arg.name ?? this.name;
    this.version = arg.version ?? this.version;
    this.release = arg.release ?? this.release;
    this.id = arg.id ?? this.id;
    this.manifestFiles = arg.manifestFiles ?? this.manifestFiles;
    this.author = arg.author ?? this.author;
    this.size = arg.size ?? this.size;
    this.alerts = arg.alerts ?? this.alerts;
    this.topLevelAncestors = arg.topLevelAncestors ?? this.topLevelAncestors;
    this.license = arg.license ?? this.license;
    this.url = `https://socket.dev/${this.type}/package/${this.name}/overview/${this.version}`;
    this.score = new Score(arg.score ?? {
      supplyChain: 0,
      quality: 0,
      license: 0,
      overall: 0,
      vulnerability: 0
    });
    this.alert_counts = {
      critical: 0,
      high: 0,
      middle: 0,
      low: 0
    };
    this.purl = `${this.type}/${this.name}@${this.version}`;
  }
}
class Purl {
  id = '';
  name = '';
  version = '';
  ecosystem = '';
  direct = false;
  author = [];
  size = 0;
  transitives = 0;
  introduced_by = [];
  capabilities = [];
  // is_new = false
  author_url = '';
  url = '';
  purl = '';
  constructor(arg) {
    this.id = arg.id ?? this.id;
    this.name = arg.name ?? this.name;
    this.version = arg.version ?? this.version;
    this.ecosystem = arg.ecosystem ?? this.ecosystem;
    this.direct = arg.direct ?? this.direct;
    this.author = arg.author ?? this.author;
    this.size = arg.size ?? this.size;
    this.transitives = arg.transitives ?? this.transitives;
    this.introduced_by = arg.introduced_by ?? this.introduced_by;
    this.url = arg.url ?? this.url;
    this.purl = arg.purl ?? this.purl;
    this.author_url = this.generateAuthorData(this.author, this.ecosystem);
  }
  generateAuthorData(authors, ecosystem) {
    const arr = [];
    for (const author of authors) {
      const url = `https://socket.dev/${ecosystem}/user/${author}`;
      arr.push(`[${author}](${url})`);
    }
    return arr.join(',');
  }
}
class Score {
  supplyChain = 0;
  quality = 0;
  license = 0;
  overall = 0;
  vulnerability = 0;
  constructor(arg) {
    this.supplyChain = (arg.supplyChain ?? 0) * 100;
    this.quality = (arg.quality ?? 0) * 100;
    this.license = (arg.license ?? 0) * 100;
    this.overall = (arg.overall ?? 0) * 100;
    this.vulnerability = (arg.vulnerability ?? 0) * 100;
  }
}

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/core/__init__.py
/* eslint-disable no-await-in-loop */
class Core {
  securityPolicy = {};
  constructor({
    owner,
    repo,
    socket
  }) {
    this.socket = socket;
    this.owner = owner;
    this.repo = repo;
    this.files = [];
  }
  async getSbomData({
    fullScanId
  }) {
    const orgFullScanResponse = await this.socket.getOrgFullScan(this.owner, fullScanId, undefined);
    if (!orgFullScanResponse.success) {
      return [];
    }
    const {
      data: readStream
    } = orgFullScanResponse;
    const sbomArtifacts = [];
    readStream.pipe(ndjson.parse()).on('data', sbomArtifact => sbomArtifacts.push(sbomArtifact));
    await events.once(readStream, 'end');
    return sbomArtifacts;
  }
  async createFullScan({
    params
  }) {
    const orgFullScanResponse = await this.socket.createOrgFullScan(this.owner,
    // Ignoring because pull_request is of type number but URLSearchParams will convert it to a string
    // @ts-ignore
    new URLSearchParams({
      repo: this.repo,
      ...params
    }), this.files);
    if (!orgFullScanResponse.success) {
      return new FullScan();
    }
    const {
      id: fullScanId
    } = orgFullScanResponse.data;
    const fullScan = new FullScan(orgFullScanResponse.data);
    if (fullScanId !== undefined) {
      fullScan.sbom_artifacts = await this.getSbomData({
        fullScanId
      });
    }
    return fullScan;
  }
  getSourceData({
    packages,
    pkg
  }) {
    const introducedBy = [];
    if (pkg.direct) {
      let manifests = pkg.manifestFiles.map(({
        file
      }) => file).join(';');
      introducedBy.push(['direct', manifests]);
    } else {
      for (const topId of pkg.topLevelAncestors) {
        const topPackage = packages[topId];
        if (!topPackage) {
          continue;
        }
        const topPurl = `${topPackage.type}/${topPackage.name}@${topPackage.version}`;
        let manifests = topPackage.manifestFiles.map(({
          file
        }) => file).join(';');
        introducedBy.push([topPurl, manifests]);
      }
    }
    return introducedBy;
  }
  createPurl({
    packageId,
    packages
  }) {
    const pkg = packages[packageId];
    const introducedBy = this.getSourceData({
      pkg,
      packages
    });
    const purl = new Purl({
      id: pkg.id,
      name: pkg.name,
      version: pkg.version,
      ecosystem: pkg.type,
      direct: pkg.direct,
      introduced_by: introducedBy,
      author: pkg.author,
      size: pkg.size,
      transitives: pkg.transitives,
      url: pkg.url,
      purl: pkg.purl
    });
    return {
      purl,
      pkg
    };
  }
  async createIssueAlerts({
    alerts,
    packages,
    pkg
  }) {
    const issues = JSON.parse(fs.readFileSync(path.join(undefined, 'issues.json'), 'utf8'));
    for (const alert of pkg.alerts) {
      const issue = issues[alert.type];
      let description = '';
      let title = '';
      let suggestion = '';
      let nextStepTitle = '';
      if (issue !== undefined) {
        description = issue['description'] ?? '';
        title = issue['title'] ?? '';
        suggestion = issue['suggestion'] ?? '';
        nextStepTitle = issue['nextStepTitle'] ?? '';
      }
      const introducedBy = this.getSourceData({
        pkg,
        packages
      });
      const issueAlert = new Issue({
        pkg_type: pkg.type,
        pkg_name: pkg.name,
        pkg_version: pkg.version,
        pkg_id: pkg.id,
        type: alert.type,
        severity: alert.severity,
        key: alert.key,
        props: alert.props,
        description,
        title,
        suggestion,
        next_step_title: nextStepTitle,
        introduced_by: introducedBy,
        purl: pkg.purl,
        url: pkg.url,
        error: false,
        ignore: false,
        warn: false,
        monitor: false
      });
      if (alert.type in this.securityPolicy) {
        const action = this.securityPolicy[alert.type]?.action;
        if (action !== undefined) {
          issueAlert[action] = true;
        }
      }
      if (issueAlert.type !== 'licenseSpdxDisj') {
        if (!(issueAlert.key in alerts)) {
          alerts[issueAlert.key] = [issueAlert];
        } else {
          alerts[issueAlert.key].push(issueAlert);
        }
      }
    }
    return alerts;
  }
  compareIssueAlerts({
    alerts,
    headScanAlerts,
    newScanAlerts
  }) {
    const consolidatedAlerts = new Set();
    for (const alertKey in newScanAlerts) {
      if (!(alertKey in headScanAlerts)) {
        const newAlerts = newScanAlerts[alertKey];
        for (const alert of newAlerts) {
          const alertStr = `${alert.purl},${alert.manifests},${alert.type}`;
          if (alert.error || alert.warn) {
            if (!consolidatedAlerts.has(alertStr)) {
              alerts.push(alert);
              consolidatedAlerts.add(alertStr);
            }
          }
        }
      } else {
        const newAlerts = newScanAlerts[alertKey];
        const headAlerts = headScanAlerts[alertKey];
        for (const alert of newAlerts) {
          const alertStr = `${alert.purl},${alert.manifests},${alert.type}`;
          if (!headAlerts.includes(alert) && !consolidatedAlerts.has(alertStr)) {
            if (alert.error || alert.warn) {
              alerts.push(alert);
              consolidatedAlerts.add(alertStr);
            }
          }
        }
      }
    }
    return alerts;
  }
  checkAlertCapabilities({
    capabilities,
    headPackage,
    packageId,
    pkg
  }) {
    const alertTypes = {
      envVars: 'Environment',
      networkAccess: 'Network',
      filesystemAccess: 'File System',
      shellAccess: 'Shell'
    };
    for (const alert of pkg.alerts) {
      let newAlert = true;
      if (headPackage !== undefined && headPackage.alerts.includes(alert)) {
        newAlert = false;
      }
      if (alert.type in alertTypes && newAlert) {
        const value = alertTypes[alert.type];
        if (!(packageId in capabilities)) {
          capabilities[packageId] = [value];
        } else {
          if (!capabilities[packageId].includes(value)) {
            capabilities[packageId].push(value);
          }
        }
      }
    }
    return capabilities;
  }
  compareCapabilities({
    headPackages,
    newPackages
  }) {
    let capabilities = {};
    for (const packageId in newPackages) {
      const pkg = newPackages[packageId];
      if (packageId in headPackages) {
        const headPackage = headPackages[packageId];
        for (const alert of pkg.alerts) {
          if (!headPackage.alerts.includes(alert)) {
            capabilities = this.checkAlertCapabilities({
              pkg,
              capabilities,
              packageId,
              headPackage
            });
          }
        }
      } else {
        capabilities = this.checkAlertCapabilities({
          pkg,
          capabilities,
          packageId
        });
      }
    }
    return capabilities;
  }
  addCapabilitiesToPurl(diff) {
    const newPackages = [];
    for (const purl of diff.newPackages) {
      if (purl.id in diff.newCapabilities) {
        const capabilities = diff.newCapabilities[purl.id];
        if (capabilities.length > 0) {
          purl.capabilities = capabilities;
          newPackages.push(purl);
        }
      } else {
        newPackages.push(purl);
      }
    }
    diff.newPackages = newPackages;
    return diff;
  }
  async compareSBOMs({
    headScan,
    newScan
  }) {
    let diff = new Diff();
    const newPackages = this.createSbomDict(newScan);
    const headPackages = this.createSbomDict(headScan);
    let newScanAlerts = {};
    let headScanAlerts = {};
    const consolidated = new Set();
    for (const packageId in newPackages) {
      const {
        pkg,
        purl
      } = this.createPurl({
        packageId,
        packages: newPackages
      });
      const basePurl = `${purl.ecosystem}/${purl.name}@${purl.version}`;
      if (!(packageId in headPackages) && pkg.direct && !consolidated.has(basePurl)) {
        diff.newPackages.push(purl);
        consolidated.add(basePurl);
      }
      newScanAlerts = await this.createIssueAlerts({
        pkg,
        alerts: newScanAlerts,
        packages: newPackages
      });
    }
    for (const packageId in headPackages) {
      const {
        pkg,
        purl
      } = this.createPurl({
        packageId,
        packages: headPackages
      });
      if (!(packageId in newPackages) && pkg.direct) {
        diff.removedPackages.push(purl);
      }
      headScanAlerts = await this.createIssueAlerts({
        pkg,
        alerts: headScanAlerts,
        packages: headPackages
      });
    }
    diff.newAlerts = this.compareIssueAlerts({
      newScanAlerts,
      headScanAlerts,
      alerts: diff.newAlerts
    });
    diff.newCapabilities = this.compareCapabilities({
      newPackages,
      headPackages
    });
    diff = this.addCapabilitiesToPurl(diff);
    return diff;
  }
  createPackageFromSbomArtifact(sbomArtifact) {
    return sbomArtifact.map(sbomArtifact => new Package({
      type: sbomArtifact.type,
      name: sbomArtifact.name,
      version: sbomArtifact.version,
      release: sbomArtifact.release,
      id: sbomArtifact.id,
      direct: sbomArtifact.direct,
      manifestFiles: sbomArtifact.manifestFiles,
      author: sbomArtifact.author,
      size: sbomArtifact.size,
      score: sbomArtifact.score,
      alerts: sbomArtifact.alerts,
      topLevelAncestors: sbomArtifact.topLevelAncestors,
      license: sbomArtifact.license
    }));
  }
  getLicenseDetails({
    package: pkg
  }) {
    const licenseText = JSON.parse(fs.readFileSync(path.join(undefined, 'license_texts.json'), 'utf8'));
    const licenseStr = licenseText[pkg.license];
    if (licenseStr !== undefined) {
      pkg.license_text = licenseStr;
    }
    return pkg;
  }
  createSbomDict(sbomArtifacts) {
    const packages = {};
    const topLevelCount = {};
    for (const sbomArtifact of sbomArtifacts) {
      let pkg = new Package({
        type: sbomArtifact.type,
        name: sbomArtifact.name,
        version: sbomArtifact.version,
        release: sbomArtifact.release,
        id: sbomArtifact.id,
        direct: sbomArtifact.direct,
        manifestFiles: sbomArtifact.manifestFiles,
        author: sbomArtifact.author,
        size: sbomArtifact.size,
        score: sbomArtifact.score,
        alerts: sbomArtifact.alerts,
        topLevelAncestors: sbomArtifact.topLevelAncestors,
        license: sbomArtifact.license
      });
      if (pkg.id in packages) {
        console.log('Duplicate package?');
      } else {
        pkg = this.getLicenseDetails({
          package: pkg
        });
        packages[pkg.id] = pkg;
        for (const topId in sbomArtifact.topLevelAncestors ?? []) {
          if (!(topId in topLevelCount)) {
            topLevelCount[topId] = 1;
          } else {
            topLevelCount[topId] += 1;
          }
        }
      }
    }
    if (Object.keys(topLevelCount).length > 0) {
      for (const packageId in topLevelCount) {
        const pkg = packages[packageId];
        if (pkg) {
          pkg.transitives = topLevelCount[packageId] ?? 0;
        }
      }
    }
    return packages;
  }
  async createNewDiff({
    params = {}
  }) {
    let headFullScanId = '';
    let headFullScan = [];
    try {
      const orgRepoResponse = await this.socket.getOrgRepo(this.owner, this.repo);
      if (orgRepoResponse.success) {
        headFullScanId = orgRepoResponse.data.head_full_scan_id ?? '';
        if (headFullScanId !== '') {
          headFullScan = await this.getSbomData({
            fullScanId: headFullScanId
          });
        }
      }
    } catch (error) {
      console.error(error);
    }
    const newFullScan = await this.createFullScan({
      params
    });
    newFullScan.packages = this.createSbomDict(newFullScan.sbom_artifacts);
    const diffReport = await this.compareSBOMs({
      newScan: newFullScan.sbom_artifacts,
      headScan: headFullScan
    });
    diffReport.packages = newFullScan.packages;
    const baseSocket = 'https://socket.dev/dashboard/org';
    diffReport.id = newFullScan.id;
    diffReport.reportUrl = `${baseSocket}/${this.owner}/sbom/${diffReport.id}`;
    if (headFullScanId !== '') {
      diffReport.diffUrl = `${baseSocket}/${this.owner}/diff/${diffReport.id}/${headFullScanId}`;
    } else {
      diffReport.diffUrl = diffReport.reportUrl;
    }
    return diffReport;
  }
}

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/core/scm_comments.py

function checkForSocketComments({
  comments
}) {
  const socketComments = {
    security: undefined,
    overview: undefined,
    ignore: []
  };
  for (const commentId in comments) {
    const comment = comments[commentId];
    if (comment.body.includes('socket-security-comment-actions')) {
      socketComments.security = comment;
    } else if (comment.body.includes('socket-overview-comment-actions')) {
      socketComments.overview = comment;
    } else if (
    // Based on:
    // To ignore an alert, reply with a comment starting with @SocketSecurity ignore
    // followed by a space separated list of ecosystem/package-name@version specifiers.
    // e.g. @SocketSecurity ignore npm/foo@1.0.0 or ignore all packages with @SocketSecurity ignore-all
    comment.body.split('\n').at(0)?.includes('SocketSecurity ignore')) {
      socketComments.ignore.push(comment);
    }
  }
  return socketComments;
}

// Parses the ignore command
// @SocketSecurity ignore pkg1 pkg2 ...
// @SocketSecurity ignore ignore-all
function parseIgnoreCommand(line) {
  const result = {
    packages: [],
    ignoreAll: false
  };
  const words = line.trim().replace(/\s+/g, ' ').split(' ');
  if (words.at(1) === 'ignore-all') {
    result.ignoreAll = true;
    return result;
  }
  if (words.at(1) === 'ignore') {
    for (let i = 2; i < words.length; i++) {
      const pkg = words[i];
      result.packages.push(pkg);
    }
    return result;
  }
  return result;
}

// Ref: https://github.com/socketdev-demo/javascript-threats/pull/89#issuecomment-2456015512
function processSecurityComment({
  ignore: ignoreComments,
  security: securityComment
}) {
  const result = [];
  let start = false;
  let ignoreAll = false;
  let ignoredPackages = [];
  for (const ignoreComment of ignoreComments) {
    const parsed = parseIgnoreCommand(ignoreComment.body?.split('\n').at(0) ?? '');
    if (parsed.ignoreAll) {
      ignoreAll = true;
      break;
    }
    ignoredPackages.push(parsed.packages);
  }

  // Split the comment body into lines and update them
  // to generate a new comment body
  for (let line of securityComment?.body?.split('\n') ?? []) {
    line = line.trim();
    if (line.includes('start-socket-alerts-table')) {
      start = true;
      result.push(line);
    } else if (start && !line.includes('end-socket-alerts-table') &&
    // is not heading line?
    !(line === '|Alert|Package|Introduced by|Manifest File|CI|' || line.includes(':---')) && line !== '') {
      // Parsing Markdown data colunms
      const [_, _title, packageLink, _introducedBy, _manifest, _ci] = line.split('|');

      // Parsing package link [npm/pkg](url)
      let [_ecosystem, pkg] = packageLink.slice(1, packageLink.indexOf(']')).split('/', 2);
      const [pkgName, pkgVersion] = pkg.split('@');

      // Checking if this package should be ignored
      let ignore = false;
      if (ignoreAll) {
        ignore = true;
      } else {
        for (const [ignoredPkgName, ignorePkgVersion] of ignoredPackages) {
          if (pkgName === ignoredPkgName && (ignorePkgVersion === '*' || pkgVersion === ignorePkgVersion)) {
            ignore = true;
            break;
          }
        }
      }
      if (ignore) {
        break;
      }
      result.push(line);
    } else if (line.includes('end-socket-alerts-table')) {
      start = false;
      result.push(line);
    } else {
      result.push(line);
    }
  }
  return result.join('\n');
}
function getIgnoreOptions({
  comments
}) {
  const ignoreCommands = [];
  let ignoreAll = false;
  for (const comment of comments.ignore) {
    let firstLine = comment.body_list[0];
    if (!ignoreAll && firstLine.includes('SocketSecurity ignore')) {
      try {
        firstLine = firstLine.replace(/@/, '');
        let [, command] = firstLine.split('SocketSecurity ');
        command = command.trim();
        if (command === 'ignore-all') {
          ignoreAll = true;
        } else {
          command = command.replace(/ignore/, '').trim();
          const [name, version] = command.split('@');
          const data = `${name}/${version}`;
          ignoreCommands.push(data);
        }
      } catch (error) {
        console.error(`Unable to process ignore command for ${comment}`);
        console.error(error);
      }
    }
  }
  return {
    ignoreAll,
    ignoreCommands
  };
}
function removeAlerts({
  comments,
  newAlerts
}) {
  const alerts = [];
  if (comments.ignore.length === 0) {
    return newAlerts;
  }
  const {
    ignoreAll,
    ignoreCommands
  } = getIgnoreOptions({
    comments
  });
  for (const alert of newAlerts) {
    if (ignoreAll) {
      break;
    } else {
      const fullName = `${alert.pkg_type}/${alert.pkg_name}`;
      const purl = `${fullName}/${alert.pkg_version}`;
      const purlStar = `${fullName}/*`;
      if (ignoreCommands.includes(purl) || ignoreCommands.includes(purlStar)) {
        console.log(`Alerts for ${alert.pkg_name}@${alert.pkg_version} ignored`);
      } else {
        console.log(`Adding alert ${alert.type} for ${alert.pkg_name}@${alert.pkg_version}`);
        alerts.push(alert);
      }
    }
  }
  return alerts;
}

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/core/github.py
/* eslint-disable no-await-in-loop */
class GitHub {
  octokit = new vendor.Octokit();
  constructor() {
    const [owner = '', repo = ''] = (process.env['GITHUB_REPOSITORY'] ?? '').split('/');
    // https://github.com/actions/checkout/issues/58#issuecomment-2264361099
    const prNumber = parseInt(process.env['GITHUB_REF']?.match(/refs\/pull\/(\d+)\/merge/)?.at(1) ?? '');
    this.owner = owner;
    this.repo = repo;
    this.prNumber = prNumber;
  }
  checkEventType() {
    switch (process.env['GITHUB_EVENT_NAME']) {
      case 'push':
        return this.prNumber ? 'diff' : 'main';
      case 'pull_request':
        // This env variable needs to be set in the GitHub action.
        // Add this code below to GitHub action:
        // - steps:
        //   - name: Get PR State
        //     if: github.event_name == 'pull_request'
        //     run: echo "EVENT_ACTION=${{ github.event.action }}" >> $GITHUB_ENV
        const eventAction = process.env['EVENT_ACTION'];
        if (!eventAction) {
          throw new Error('Missing event action');
        }
        if (['opened', 'synchronize'].includes(eventAction)) {
          return 'diff';
        } else {
          console.log(`Pull request action: ${eventAction} is not supported`);
          process.exit();
        }
      case 'issue_comment':
        return 'comment';
      default:
        throw new Error(`Unknown event type: ${process.env['GITHUB_EVENT_NAME']}`);
    }
  }
  async getCommentsForPR() {
    const {
      data: githubComments
    } = await this.octokit.rest.issues.listComments({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber
    });
    const comments = {};
    for (const githubComment of githubComments) {
      comments[githubComment.id] = new Comment({
        id: githubComment.id,
        body: githubComment.body ?? '',
        body_list: (githubComment.body ?? '').split('\n')
      });
    }
    return checkForSocketComments({
      comments
    });
  }
  async commentReactionExists({
    commentId
  }) {
    const {
      data
    } = await this.octokit.reactions.listForIssueComment({
      owner: this.owner,
      repo: this.repo,
      comment_id: commentId
    });
    return data.some(reaction => reaction.content === '+1');
  }
  async postReaction({
    commentId
  }) {
    await this.octokit.reactions.createForIssueComment({
      owner: this.owner,
      repo: this.repo,
      comment_id: commentId,
      content: '+1'
    });
  }
  async handleIgnoreReactons({
    comments
  }) {
    for (const ignoreComment of comments.ignore) {
      if (ignoreComment.body?.includes('SocketSecurity ignore') && !(await this.commentReactionExists({
        commentId: ignoreComment.id
      }))) {
        await this.postReaction({
          commentId: ignoreComment.id
        });
      }
    }
  }
  async updateComment({
    body,
    id
  }) {
    await this.octokit.issues.updateComment({
      owner: this.owner,
      repo: this.repo,
      comment_id: id,
      body
    });
  }
  async removeCommentAlerts({
    comments
  }) {
    const securityAlert = comments.security;
    if (securityAlert !== undefined) {
      const newBody = processSecurityComment({
        security: comments.security,
        ignore: comments.ignore
      });
      await this.handleIgnoreReactons({
        comments
      });
      await this.updateComment({
        id: securityAlert.id,
        body: newBody
      });
    }
  }
  async postComment({
    body
  }) {
    await this.octokit.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body
    });
  }
  async addSocketComments({
    comments,
    newOverviewComment,
    newSecurityComment,
    overviewComment,
    securityComment
  }) {
    const {
      overview: existingOverviewComment,
      security: existingSecurityComment
    } = comments;
    if (newOverviewComment) {
      console.log('New Dependency Overview comment');
      if (existingOverviewComment !== undefined) {
        console.log('Previous version of Dependency Overview, updating');
        await this.updateComment({
          body: overviewComment,
          id: existingOverviewComment.id
        });
      } else {
        console.log('No previous version of Dependency Overview, posting');
        await this.postComment({
          body: overviewComment
        });
      }
    }
    if (newSecurityComment) {
      console.log('New Security Issue Comment');
      if (existingSecurityComment !== undefined) {
        console.log('Previous version of Security Issue comment, updating');
        await this.updateComment({
          body: securityComment,
          id: existingSecurityComment.id
        });
      } else {
        console.log('No Previous version of Security Issue comment, posting');
        await this.postComment({
          body: securityComment
        });
      }
    }
  }
}

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/core/messages.py

function createPurlLink(purl) {
  const packageUrl = `[${purl.purl}](${purl.url})`;
  return packageUrl;
}
function createAddedTable(diff) {
  const overviewTable = ['Package', 'Direct', 'Capabilities', 'Transitives', 'Size', 'Author'];
  const rows = [];
  for (const added of diff.newPackages) {
    const packageUrl = createPurlLink(added);
    const capabilities = added.capabilities.join(', ');
    const row = [packageUrl, added.direct, capabilities, added.transitives, `${added.size} KB`, added.author_url];
    rows.push(row);
  }
  let md = '';
  md += `|${overviewTable.join('|')}|\n`;
  md += '|---|---|---|---|---|---|\n';
  for (const row of rows) {
    md += `|${row.join('|')}|\n`;
  }
  return md;
}
function createRemoveLine(diff) {
  const removedLine = ['Removed packages:'];
  for (const removed of diff.removedPackages) {
    const packageUrl = createPurlLink(removed);
    removedLine.push(packageUrl);
  }
  return removedLine.join(', ');
}
function dependencyOverviewTemplate(diff) {
  let md = '';
  md += '<!-- socket-overview-comment-actions -->\n';
  md += '# Socket Security: Dependency Overview\n';
  md += 'New and removed dependencies detected. Learn more about [socket.dev](https://socket.dev)\n\n';
  md += createAddedTable(diff);
  if (diff.removedPackages.length > 0) {
    md += createRemoveLine(diff);
  }
  return md;
}
function createSources(alert) {
  const sources = [];
  const manifests = [];
  for (const [source, manifest] of alert.introduced_by) {
    const addStr = `<li>${manifest}</li>`;
    const sourceStr = `<li>${source}</li>`;
    if (!sources.includes(sourceStr)) {
      sources.push(sourceStr);
    }
    if (!manifests.includes(addStr)) {
      manifests.push(addStr);
    }
  }
  let manifestList = manifests.join('');
  let sourceList = sources.join('');
  const manifestStr = `<ul>${manifestList}</ul>`;
  const sourcesStr = `<ul>${sourceList}</ul>`;
  return [manifestStr, sourcesStr];
}
function createSecurityAlertTable(diff) {
  const alertTable = ['Alert', 'Package', 'Introduced by', 'Manifest File', 'CI'];
  const nextSteps = {};
  const ignoreCommands = [];
  const rows = [];
  for (const alert of diff.newAlerts) {
    if (!(alert.next_step_title in nextSteps)) {
      nextSteps[alert.next_step_title] = [alert.description, alert.suggestion];
    }
    const ignore = `\`SocketSecurity ignore ${alert.purl}\``;
    if (!ignoreCommands.includes(ignore)) {
      ignoreCommands.push(ignore);
    }
    const [manifestStr, sourceStr] = createSources(alert);
    const purlUrl = `[${alert.purl}](${alert.url})`;
    if (alert.error) {
      alert.emoji = ':no_entry_sign:';
    } else {
      alert.emoji = ':warning:';
    }
    const row = [alert.title, purlUrl, sourceStr, manifestStr, alert.emoji];
    if (!rows.some(r => r.join() === row.join())) {
      rows.push(row);
    }
  }
  let md = '';
  md += `|${alertTable.join('|')}|\n`;
  md += '|---|---|---|---|---|\n';
  for (const row of rows) {
    md += `|${row.join('|')}|\n`;
  }
  return {
    ignoreCommands,
    nextSteps,
    mdTable: md
  };
}
function createNextSteps(nextSteps) {
  let md = '';
  for (const step in nextSteps) {
    const detail = nextSteps[step];
    md += '<details>\n';
    md += `<summary>${step}</summary>\n`;
    for (const line of detail) {
      md += `${line}\n`;
    }
    md += '</details>\n';
  }
  return md;
}
function createDeeperLook() {
  let md = '';
  md += '<details>\n';
  md += '<summary>Take a deeper look at the dependency</summary>\n';
  md += "Take a moment to review the security alert above. Review the linked package source code to understand the potential risk. Ensure the package is not malicious before proceeding. If you're unsure how to proceed, reach out to your security team or ask the Socket team for help at support [AT] socket [DOT] dev.\n";
  md += '</details>\n';
  return md;
}
function createRemovePackage() {
  let md = '';
  md += '<details>\n';
  md += '<summary>Remove the package</summary>\n';
  md += 'If you happen to install a dependency that Socket reports as [https://socket.dev/npm/issue/malware](Known Malware) you should immediately remove it and select a different dependency. For other alert types, you may may wish to investigate alternative packages or consider if there are other ways to mitigate the specific risk posed by the dependency.\n';
  md += '</details>\n';
  return md;
}
function createAcceptableRisk(ignoreCommands) {
  let md = '';
  md += '<details>\n';
  md += '<summary>Mark a package as acceptable risk</summary>\n';
  md += 'To ignore an alert, reply with a comment starting with `SocketSecurity ignore` followed by a space separated list of `ecosystem/package-name@version` specifiers. e.g. `SocketSecurity ignore npm/foo@1.0.0` or ignore all packages with `SocketSecurity ignore-all`\n';
  md += '<ul>\n';
  for (const ignore of ignoreCommands) {
    md += `<li>${ignore}</li>\n`;
  }
  md += '</ul>\n';
  md += '</details>\n';
  return md;
}
function securityCommentTemplate(diff) {
  let md = '';
  md += '<!-- socket-security-comment-actions -->\n';
  md += '# Socket Security: Issues Report\n';
  md += 'Potential security issues detected. Learn more about [socket.dev](https://socket.dev)\n';
  md += 'To accept the risk, merge this PR and you will not be notified again.\n\n';
  md += '<!-- start-socket-alerts-table -->\n';
  const {
    ignoreCommands,
    mdTable,
    nextSteps
  } = createSecurityAlertTable(diff);
  md += mdTable;
  md += '<!-- end-socket-alerts-table -->\n\n';
  md += createNextSteps(nextSteps);
  md += createDeeperLook();
  md += createRemovePackage();
  md += createAcceptableRisk(ignoreCommands);
  return md.trim();
}

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/socketcli.py


// TODO: is this a github action handler?
async function runAction(githubEventBefore, githubEventAfter) {
  //TODO
  const socket = new sdk.SocketSdk(index.getDefaultToken());
  const git = simpleGit.simpleGit();
  const changedFiles = (await git.diff(process.env['GITHUB_EVENT_NAME'] === 'pull_request' ? ['--name-only', 'HEAD^1', 'HEAD'] : ['--name-only', githubEventBefore, githubEventAfter])).split('\n');
  console.log({
    changedFiles
  });
  // supportedFiles have 3-level deep globs
  const patterns = Object.values(await socket.getReportSupportedFiles()).flatMap(i => Object.values(i)).flatMap(i => Object.values(i)).flatMap(i => Object.values(i));
  const files = micromatch(changedFiles, patterns);
  const scm = new GitHub();
  if (scm.checkEventType() === 'comment') {
    console.log('Comment initiated flow');
    const comments = await scm.getCommentsForPR();
    await scm.removeCommentAlerts({
      comments
    });
  } else if (scm.checkEventType() === 'diff') {
    console.log('Push initiated flow');
    const core = new Core({
      owner: scm.owner,
      repo: scm.repo,
      files,
      socket
    });
    const diff = await core.createNewDiff({});
    const comments = await scm.getCommentsForPR();
    diff.newAlerts = removeAlerts({
      comments,
      newAlerts: diff.newAlerts
    });
    const overviewComment = dependencyOverviewTemplate(diff);
    const securityComment = securityCommentTemplate(diff);
    let newSecurityComment = true;
    let newOverviewComment = true;
    let updateOldSecurityComment = comments.security !== undefined;
    let updateOldOverviewComment = comments.overview !== undefined;
    if (diff.newAlerts.length === 0) {
      if (!updateOldSecurityComment) {
        newSecurityComment = false;
        console.log('No new alerts or security issue comment disabled');
      } else {
        console.log('Updated security comment with no new alerts');
      }
    }
    if (diff.newPackages.length === 0 && diff.removedPackages.length === 0) {
      if (!updateOldOverviewComment) {
        newOverviewComment = false;
        console.log('No new/removed packages or Dependency Overview comment disabled');
      } else {
        console.log('Updated overview comment with no dependencies');
      }
    }
    await scm.addSocketComments({
      securityComment,
      overviewComment,
      comments,
      newSecurityComment,
      newOverviewComment
    });
  }
}

function getFlagListOutput(list, indent, {
  keyPrefix = '--',
  padName
} = {}) {
  return getHelpListOutput({
    ...list
  }, indent, {
    keyPrefix,
    padName
  });
}
function getHelpListOutput(list, indent, {
  keyPrefix = '',
  padName = 18
} = {}) {
  let result = '';
  const names = Object.keys(list).sort();
  for (const name of names) {
    const rawDescription = list[name];
    const description = (typeof rawDescription === 'object' ? rawDescription.description : rawDescription) || '';
    result += ''.padEnd(indent) + (keyPrefix + name).padEnd(padName) + description + '\n';
  }
  return result.trim();
}

// TODO: not sure if I'm missing something but meow doesn't seem to expose this?

// Note: we use this description in getFlagListOutput, meow doesn't care

const commonFlags = {
  help: {
    type: 'boolean',
    default: false,
    shortFlag: 'h',
    description: 'Print this help.'
  }
};
const outputFlags = {
  json: {
    type: 'boolean',
    shortFlag: 'j',
    default: false,
    description: 'Output result as json'
  },
  markdown: {
    type: 'boolean',
    shortFlag: 'm',
    default: false,
    description: 'Output result as markdown'
  }
};
const validationFlags = {
  all: {
    type: 'boolean',
    default: false,
    description: 'Include all issues'
  },
  strict: {
    type: 'boolean',
    default: false,
    description: 'Exits with an error code if any matching issues are found'
  }
};

// Property names are picked such that the name is at the top when the props
// get ordered by alphabet while flags is near the bottom and the help text
// at the bottom, because they tend ot occupy the most lines of code.

async function meowWithSubcommands(subcommands, options) {
  const {
    aliases = {},
    argv,
    importMeta,
    name,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const [commandOrAliasName, ...rawCommandArgv] = argv;
  // If we got at least some args, then lets find out if we can find a command
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName];
    // First: Resolve argv data from alias if its an alias that's been given
    const [commandName, ...commandArgv] = alias ? [...alias.argv, ...rawCommandArgv] : [commandOrAliasName, ...rawCommandArgv];
    // Second: Find a command definition using that data
    const commandDefinition = commandName ? subcommands[commandName] : undefined;
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      });
    }
  }
  const flags = {
    ...commonFlags,
    ...additionalOptions.flags
  };
  // ...else we provide basic instructions and help
  const cli = vendor.meow(`
    Usage
      $ ${name} <command>

    Commands
      ${getHelpListOutput({
    ...objects.toSortedObject(Object.fromEntries(Object.entries(subcommands).filter(({
      1: subcommand
    }) => !subcommand.hidden))),
    ...objects.toSortedObject(Object.fromEntries(Object.entries(aliases).filter(({
      1: alias
    }) => {
      const {
        hidden
      } = alias;
      const cmdName = hidden ? '' : alias.argv[0];
      const subcommand = cmdName ? subcommands[cmdName] : undefined;
      return subcommand && !subcommand.hidden;
    })))
  }, 6)}

    Options
      ${getFlagListOutput(flags, 6)}

    Examples
      $ ${name} --help
  `, {
    argv,
    importMeta,
    ...additionalOptions,
    flags
  });
  cli.showHelp();
}

/**
 * Note: meow will exit immediately if it calls its .showHelp()
 */
function meowOrExit({
  allowUnknownFlags,
  // commands that pass-through args need to allow this
  argv,
  config,
  importMeta,
  parentName
}) {
  const command = `${parentName} ${config.commandName}`;
  const help = config.help(command, config);

  // This exits if .printHelp() is called either by meow itself or by us.
  const cli = vendor.meow({
    argv,
    description: config.description,
    help,
    importMeta,
    flags: config.flags,
    allowUnknownFlags: Boolean(allowUnknownFlags)
  });
  return cli;
}

// https://github.com/SocketDev/socket-python-cli/blob/6d4fc56faee68d3a4764f1f80f84710635bdaf05/socketsecurity/socketcli.py

const config$z = {
  commandName: 'action',
  description: 'Socket action command',
  // GitHub Action ?
  hidden: true,
  flags: {
    // This flag is unused
    // socketSecurityApiKey: { // deprecate this asap.
    //   type: 'string',
    //   default: 'env var SOCKET_SECURITY_API_KEY',
    //   description: 'Socket API token'
    // },
    githubEventBefore: {
      type: 'string',
      default: '',
      description: 'Before marker'
    },
    githubEventAfter: {
      type: 'string',
      default: '',
      description: 'After marker'
    }
  },
  help: (parentName, {
    commandName,
    flags
  }) => `
    Usage
      $ ${parentName} ${commandName} [options]

    Options
      ${getFlagListOutput(flags, 6)}
  `
};
const cmdAction = {
  description: config$z.description,
  hidden: config$z.hidden,
  run: run$z
};
async function run$z(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$z,
    importMeta,
    parentName
  });
  const githubEventBefore = String(cli.flags['githubEventBefore'] || '');
  const githubEventAfter = String(cli.flags['githubEventAfter'] || '');
  await runAction(githubEventBefore, githubEventAfter);
}

const {
  API_V0_URL
} = constants;
function handleUnsuccessfulApiResponse(_name, result, spinner) {
  // SocketSdkErrorType['error'] is not typed.
  const resultErrorMessage = result.error?.message;
  const message = typeof resultErrorMessage === 'string' ? resultErrorMessage : 'No error message returned';
  if (result.status === 401 || result.status === 403) {
    spinner.stop();
    throw new index.AuthError(message);
  }
  spinner.error(`${colors.bgRed(colors.white('API returned an error:'))} ${message}`);
  process$1.exit(1);
}
async function handleApiCall(value, description) {
  let result;
  try {
    result = await value;
  } catch (cause) {
    throw new Error(`Failed ${description}`, {
      cause
    });
  }
  return result;
}
async function handleAPIError(code) {
  if (code === 400) {
    return 'One of the options passed might be incorrect.';
  } else if (code === 403) {
    return 'You might be trying to access an organization that is not linked to the API key you are logged in with.';
  }
}
async function queryAPI(path, apiToken) {
  return await fetch(`${API_V0_URL}/${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiToken}:${apiToken}`)}`
    }
  });
}

// Note: Widgets does not seem to actually work as code :'(

// Note: This maps `new Date(date).getMonth()` to English three letters
const Months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const METRICS = ['total_critical_alerts', 'total_high_alerts', 'total_medium_alerts', 'total_low_alerts', 'total_critical_added', 'total_medium_added', 'total_low_added', 'total_high_added', 'total_critical_prevented', 'total_high_prevented', 'total_medium_prevented', 'total_low_prevented'];
async function displayAnalytics({
  apiToken,
  filePath,
  outputJson,
  repo,
  scope,
  time
}) {
  const spinner$1 = new spinner.Spinner({
    text: 'Fetching analytics data'
  }).start();
  let data;
  if (scope === 'org') {
    data = await fetchOrgAnalyticsData(time, spinner$1, apiToken);
  } else if (repo) {
    data = await fetchRepoAnalyticsData(repo, time, spinner$1, apiToken);
  }
  if (data) {
    if (outputJson && !filePath) {
      console.log(data);
    } else if (filePath) {
      try {
        await fs$1.writeFile(filePath, JSON.stringify(data), 'utf8');
        console.log(`Data successfully written to ${filePath}`);
      } catch (e) {
        console.error(e);
      }
    } else {
      const fdata = scope === 'org' ? formatData(data, 'org') : formatData(data, 'repo');
      displayAnalyticsScreen(fdata);
    }
  }
}
function displayAnalyticsScreen(data) {
  const screen = new ScreenWidget({});
  const grid = new contrib.grid({
    rows: 5,
    cols: 4,
    screen
  });
  renderLineCharts(grid, screen, 'Total critical alerts', [0, 0, 1, 2], data['total_critical_alerts']);
  renderLineCharts(grid, screen, 'Total high alerts', [0, 2, 1, 2], data['total_high_alerts']);
  renderLineCharts(grid, screen, 'Total critical alerts added to the main branch', [1, 0, 1, 2], data['total_critical_added']);
  renderLineCharts(grid, screen, 'Total high alerts added to the main branch', [1, 2, 1, 2], data['total_high_added']);
  renderLineCharts(grid, screen, 'Total critical alerts prevented from the main branch', [2, 0, 1, 2], data['total_critical_prevented']);
  renderLineCharts(grid, screen, 'Total high alerts prevented from the main branch', [2, 2, 1, 2], data['total_high_prevented']);
  renderLineCharts(grid, screen, 'Total medium alerts prevented from the main branch', [3, 0, 1, 2], data['total_medium_prevented']);
  renderLineCharts(grid, screen, 'Total low alerts prevented from the main branch', [3, 2, 1, 2], data['total_low_prevented']);
  const bar = grid.set(4, 0, 1, 2, contrib.bar, {
    label: 'Top 5 alert types',
    barWidth: 10,
    barSpacing: 17,
    xOffset: 0,
    maxHeight: 9,
    barBgColor: 'magenta'
  });
  screen.append(bar); //must append before setting data

  bar.setData({
    titles: Object.keys(data.top_five_alert_types),
    data: Object.values(data.top_five_alert_types)
  });
  screen.render();
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
}
async function fetchOrgAnalyticsData(time, spinner, apiToken) {
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getOrgAnalytics(time.toString()), 'fetching analytics data');
  if (result.success === false) {
    handleUnsuccessfulApiResponse('getOrgAnalytics', result, spinner);
    return undefined;
  }
  spinner.stop();
  if (!result.data.length) {
    console.log('No analytics data is available for this organization yet.');
    return undefined;
  }
  return result.data;
}
async function fetchRepoAnalyticsData(repo, time, spinner, apiToken) {
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getRepoAnalytics(repo, time.toString()), 'fetching analytics data');
  if (result.success === false) {
    handleUnsuccessfulApiResponse('getRepoAnalytics', result, spinner);
    return undefined;
  }
  spinner.stop();
  if (!result.data.length) {
    console.log('No analytics data is available for this organization yet.');
    return undefined;
  }
  return result.data;
}
function formatData(data, scope) {
  const formattedData = {};
  const sortedTopFiveAlerts = {};
  const totalTopAlerts = {};
  for (const metric of METRICS) {
    formattedData[metric] = {};
  }
  if (scope === 'org') {
    for (const entry of data) {
      const topFiveAlertTypes = entry['top_five_alert_types'];
      for (const type of Object.keys(topFiveAlertTypes)) {
        const count = topFiveAlertTypes[type] ?? 0;
        if (!totalTopAlerts[type]) {
          totalTopAlerts[type] = count;
        } else {
          totalTopAlerts[type] += count;
        }
      }
    }
    for (const metric of METRICS) {
      const formatted = formattedData[metric];
      for (const entry of data) {
        const date = formatDate(entry['created_at']);
        if (!formatted[date]) {
          formatted[date] = entry[metric];
        } else {
          formatted[date] += entry[metric];
        }
      }
    }
  } else if (scope === 'repo') {
    for (const entry of data) {
      const topFiveAlertTypes = entry['top_five_alert_types'];
      for (const type of Object.keys(topFiveAlertTypes)) {
        const count = topFiveAlertTypes[type] ?? 0;
        if (!totalTopAlerts[type]) {
          totalTopAlerts[type] = count;
        } else if (count > (totalTopAlerts[type] ?? 0)) {
          totalTopAlerts[type] = count;
        }
      }
    }
    for (const entry of data) {
      for (const metric of METRICS) {
        formattedData[metric][formatDate(entry['created_at'])] = entry[metric];
      }
    }
  }
  const topFiveAlertEntries = Object.entries(totalTopAlerts).sort(({
    1: a
  }, {
    1: b
  }) => b - a).slice(0, 5);
  for (const {
    0: key,
    1: value
  } of topFiveAlertEntries) {
    sortedTopFiveAlerts[key] = value;
  }
  return {
    ...formattedData,
    top_five_alert_types: sortedTopFiveAlerts
  };
}
function formatDate(date) {
  return `${Months[new Date(date).getMonth()]} ${new Date(date).getDate()}`;
}
function renderLineCharts(grid, screen, title, coords, data) {
  const line = grid.set(...coords, contrib.line, {
    style: {
      line: 'cyan',
      text: 'cyan',
      baseline: 'black'
    },
    xLabelPadding: 0,
    xPadding: 0,
    xOffset: 0,
    wholeNumbersOnly: true,
    legend: {
      width: 1
    },
    label: title
  });
  screen.append(line);
  const lineData = {
    x: Object.keys(data),
    y: Object.values(data)
  };
  line.setData([lineData]);
}

const config$y = {
  commandName: 'analytics',
  description: `Look up analytics data`,
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    scope: {
      type: 'string',
      shortFlag: 's',
      default: 'org',
      description: "Scope of the analytics data - either 'org' or 'repo', default: org"
    },
    time: {
      type: 'number',
      shortFlag: 't',
      default: 7,
      description: 'Time filter - either 7, 30 or 90, default: 7'
    },
    repo: {
      type: 'string',
      shortFlag: 'r',
      default: '',
      description: 'Name of the repository'
    },
    file: {
      type: 'string',
      shortFlag: 'f',
      default: '',
      description: 'Path to a local file to save the output'
    }
  },
  help: (parentName, {
    commandName,
    flags
  }) => `
    Usage
      $ ${parentName} ${commandName} --scope=<scope> --time=<time filter>

    Default parameters are set to show the organization-level analytics over the
    last 7 days.

    Options
      ${getFlagListOutput(flags, 6)}

    Examples
      $ ${parentName} ${commandName} --scope=org --time=7
      $ ${parentName} ${commandName} --scope=org --time=30
      $ ${parentName} ${commandName} --scope=repo --repo=test-repo --time=30
  `
};
const cmdAnalytics = {
  description: config$y.description,
  hidden: config$y.hidden,
  run: run$y
};
async function run$y(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$y,
    importMeta,
    parentName
  });
  const {
    repo,
    scope,
    time
  } = cli.flags;
  const badScope = scope !== 'org' && scope !== 'repo';
  const badTime = time !== 7 && time !== 30 && time !== 90;
  const badRepo = scope === 'repo' && !repo;
  if (badScope || badTime || badRepo) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Scope must be "repo" or "org" ${badScope ? colors.red('(bad!)') : colors.green('(ok)')}\n
      - The time filter must either be 7, 30 or 90 ${badTime ? colors.red('(bad!)') : colors.green('(ok)')}\n
      - Repository name using --repo when scope is "repo" ${badRepo ? colors.red('(bad!)') : colors.green('(ok)')}\n
    `);
    cli.showHelp();
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API token.');
  }
  return await displayAnalytics({
    apiToken,
    scope,
    time,
    repo: String(repo || ''),
    outputJson: Boolean(cli.flags['json']),
    filePath: String(cli.flags['file'] || '')
  });
}

async function getAuditLog({
  apiToken,
  orgSlug,
  outputJson,
  outputMarkdown,
  page,
  perPage,
  type
}) {
  const spinner$1 = new spinner.Spinner({
    text: `Looking up audit log for ${orgSlug}\n`
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getAuditLogEvents(orgSlug, {
    outputJson,
    outputMarkdown,
    orgSlug,
    type,
    page,
    per_page: perPage
  }), `Looking up audit log for ${orgSlug}\n`);
  if (!result.success) {
    handleUnsuccessfulApiResponse('getAuditLogEvents', result, spinner$1);
    return;
  }
  spinner$1.stop();
  const data = [];
  const logDetails = {};
  for (const d of result.data.results) {
    const {
      created_at
    } = d;
    if (created_at) {
      const name = `${new Date(created_at).toLocaleDateString('en-us', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      })} - ${d.user_email} - ${d.type} - ${d.ip_address} - ${d.user_agent}`;
      data.push({
        name
      }, new prompts.Separator());
      logDetails[name] = JSON.stringify(d.payload);
    }
  }
  console.log(logDetails[await prompts.select({
    message: type ? `\n Audit log for: ${orgSlug} with type: ${type}\n` : `\n Audit log for: ${orgSlug}\n`,
    choices: data,
    pageSize: 30
  })]);
}

const config$x = {
  commandName: 'audit-log',
  description: 'Look up the audit log for an organization',
  hidden: false,
  flags: {
    type: {
      type: 'string',
      shortFlag: 't',
      default: '',
      description: 'Type of log event'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Results per page - default is 30'
    },
    page: {
      type: 'number',
      shortFlag: 'p',
      default: 1,
      description: 'Page number - default is 1'
    },
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg
  `
};
const cmdAuditLog = {
  description: config$x.description,
  hidden: config$x.hidden,
  run: run$x
};
async function run$x(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$x,
    importMeta,
    parentName
  });
  const type = String(cli.flags['type'] || '');
  const [orgSlug = ''] = cli.input;
  if (!orgSlug) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
    - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
    `);
    config$x.help(parentName, config$x);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await getAuditLog({
    apiToken,
    orgSlug,
    outputJson: Boolean(cli.flags['json']),
    outputMarkdown: Boolean(cli.flags['markdown']),
    page: Number(cli.flags['page'] || 0),
    perPage: Number(cli.flags['perPage'] || 0),
    type: type.charAt(0).toUpperCase() + type.slice(1)
  });
}

const {
  SBOM_SIGN_ALGORITHM,
  // Algorithm. Example: RS512
  SBOM_SIGN_PRIVATE_KEY,
  // Location to the RSA private key
  SBOM_SIGN_PUBLIC_KEY // Optional. Location to the RSA public key
} = process$1.env;
const {
  NPM: NPM$e,
  PNPM: PNPM$8,
  cdxgenBinPath,
  synpBinPath
} = constants;
const nodejsPlatformTypes = new Set(['javascript', 'js', 'nodejs', NPM$e, PNPM$8, 'ts', 'tsx', 'typescript']);
async function runCycloneDX(yargv) {
  let cleanupPackageLock = false;
  if (yargv.type !== 'yarn' && nodejsPlatformTypes.has(yargv.type) && fs.existsSync('./yarn.lock')) {
    if (fs.existsSync('./package-lock.json')) {
      yargv.type = NPM$e;
    } else {
      // Use synp to create a package-lock.json from the yarn.lock,
      // based on the node_modules folder, for a more accurate SBOM.
      try {
        await npm.runBin(await fs.promises.realpath(synpBinPath), ['--source-file', './yarn.lock']);
        yargv.type = NPM$e;
        cleanupPackageLock = true;
      } catch {}
    }
  }
  await npm.runBin(await fs.promises.realpath(cdxgenBinPath), argvToArray(yargv), {
    env: {
      NODE_ENV: '',
      SBOM_SIGN_ALGORITHM,
      SBOM_SIGN_PRIVATE_KEY,
      SBOM_SIGN_PUBLIC_KEY
    },
    stdio: 'inherit'
  });
  if (cleanupPackageLock) {
    try {
      await fs.promises.rm('./package-lock.json');
    } catch {}
  }
  const fullOutputPath = path.join(process$1.cwd(), yargv.output);
  if (fs.existsSync(fullOutputPath)) {
    console.log(colors.cyanBright(`${yargv.output} created!`));
  }
}
function argvToArray(argv) {
  if (argv['help']) return ['--help'];
  const result = [];
  for (const {
    0: key,
    1: value
  } of Object.entries(argv)) {
    if (key === '_' || key === '--') continue;
    if (key === 'babel' || key === 'install-deps' || key === 'validate') {
      // cdxgen documents no-babel, no-install-deps, and no-validate flags so
      // use them when relevant.
      result.push(`--${value ? key : `no-${key}`}`);
    } else if (value === true) {
      result.push(`--${key}`);
    } else if (typeof value === 'string') {
      result.push(`--${key}`, String(value));
    } else if (Array.isArray(value)) {
      result.push(`--${key}`, ...value.map(String));
    }
  }
  if (argv['--']) {
    result.push('--', ...argv['--']);
  }
  return result;
}

// import { meowOrExit } from '../../utils/meow-with-subcommands'

// TODO: convert yargs to meow. Or convert all the other things to yargs.
const toLower = arg => arg.toLowerCase();
const arrayToLower = arg => arg.map(toLower);
const yargsConfig = {
  configuration: {
    'camel-case-expansion': false,
    'strip-aliased': true,
    'parse-numbers': false,
    'populate--': true,
    'unknown-options-as-args': true
  },
  coerce: {
    author: arrayToLower,
    filter: arrayToLower,
    only: arrayToLower,
    profile: toLower,
    standard: arrayToLower,
    type: toLower
  },
  default: {
    //author: ['OWASP Foundation'],
    //'auto-compositions': true,
    //babel: true,
    //evidence: false,
    //'include-crypto': false,
    //'include-formulation': false,

    // Default 'install-deps' to `false` and 'lifecycle' to 'pre-build' to
    // sidestep arbitrary code execution during a cdxgen scan.
    // https://github.com/CycloneDX/cdxgen/issues/1328
    'install-deps': false,
    lifecycle: 'pre-build',
    //output: 'bom.json',
    //profile: 'generic',
    //'project-version': '',
    //recurse: true,
    //'server-host': '127.0.0.1',
    //'server-port': '9090',
    //'spec-version': '1.5',
    type: 'js'
    //validate: true,
  },
  alias: {
    help: ['h'],
    output: ['o'],
    print: ['p'],
    recurse: ['r'],
    'resolve-class': ['c'],
    type: ['t'],
    version: ['v']
  },
  array: [{
    key: 'author',
    type: 'string'
  }, {
    key: 'exclude',
    type: 'string'
  }, {
    key: 'filter',
    type: 'string'
  }, {
    key: 'only',
    type: 'string'
  }, {
    key: 'standard',
    type: 'string'
  }],
  boolean: ['auto-compositions', 'babel', 'deep', 'evidence', 'fail-on-error', 'generate-key-and-sign', 'help', 'include-formulation', 'include-crypto', 'install-deps', 'print', 'required-only', 'server', 'validate', 'version'],
  string: ['api-key', 'lifecycle', 'output', 'parent-project-id', 'profile', 'project-group', 'project-name', 'project-version', 'project-id', 'server-host', 'server-port', 'server-url', 'spec-version']
};
const config$w = {
  description: 'Create an SBOM with CycloneDX generator (cdxgen)',
  hidden: false};
const cmdCdxgen = {
  description: config$w.description,
  hidden: config$w.hidden,
  run: run$w
};
async function run$w(argv, _importMeta, {
  parentName: _parentName
}) {
  // const cli = meowOrExit({
  //   allowUnknownFlags: true,
  //   argv,
  //   config,
  //   importMeta,
  //   parentName,
  // })
  //
  //
  // if (cli.input.length)
  //   console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
  //     - Unexpected arguments\n
  //   `)
  //   config.help(parentName, config)
  //   return
  // }

  // TODO: convert to meow
  const yargv = {
    ...yargsParse(argv, yargsConfig)
  }; // as Record<string, unknown>;

  const unknown = yargv._;
  const {
    length: unknownLength
  } = unknown;
  if (unknownLength) {
    process$1.exitCode = 1;
    console.error(`Unknown ${words.pluralize('argument', unknownLength)}: ${yargv._.join(', ')}`);
    return;
  }
  if (yargv.output === undefined) {
    yargv.output = 'socket-cdx.json';
  }
  await runCycloneDX(yargv);
}

// @ts-ignore
async function findDependencies({
  limit,
  offset,
  outputJson
}) {
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  const spinner$1 = new spinner.Spinner({
    text: 'Searching dependencies...'
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.searchDependencies({
    limit,
    offset
  }), 'Searching dependencies');
  if (!result.success) {
    handleUnsuccessfulApiResponse('searchDependencies', result, spinner$1);
    return;
  }
  spinner$1.stop('Organization dependencies:');
  if (outputJson) {
    console.log(result.data);
    return;
  }
  const options = {
    columns: [{
      field: 'namespace',
      name: colors.cyan('Namespace')
    }, {
      field: 'name',
      name: colors.cyan('Name')
    }, {
      field: 'version',
      name: colors.cyan('Version')
    }, {
      field: 'repository',
      name: colors.cyan('Repository')
    }, {
      field: 'branch',
      name: colors.cyan('Branch')
    }, {
      field: 'type',
      name: colors.cyan('Type')
    }, {
      field: 'direct',
      name: colors.cyan('Direct')
    }]
  };
  console.log(chalkTable(options, result.data.rows));
}

const config$v = {
  commandName: 'dependencies',
  description: 'Search for any dependency that is being used in your organization',
  hidden: false,
  flags: {
    ...commonFlags,
    limit: {
      type: 'number',
      shortFlag: 'l',
      default: 50,
      description: 'Maximum number of dependencies returned'
    },
    offset: {
      type: 'number',
      shortFlag: 'o',
      default: 0,
      description: 'Page number'
    },
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      ${command} --limit 20 --offset 10
  `
};
const cmdScanCreate$1 = {
  description: config$v.description,
  hidden: config$v.hidden,
  run: run$v
};
async function run$v(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$v,
    importMeta,
    parentName
  });

  // TODO: markdown flag is ignored
  await findDependencies({
    limit: Number(cli.flags['limit'] || 0) || 0,
    offset: Number(cli.flags['offset'] || 0) || 0,
    outputJson: Boolean(cli.flags['json'])
  });
}

async function getDiffScan({
  after,
  before,
  file,
  orgSlug,
  outputJson
}, apiToken) {
  const spinnerText = 'Getting diff scan... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const response = await queryAPI(`${orgSlug}/full-scans/diff?before=${before}&after=${after}&preview`, apiToken);
  const data = await response.json();
  if (!response.ok) {
    const err = await handleAPIError(response.status);
    spinner$1.error(`${colors.bgRed(colors.white(response.statusText))}: ${err}`);
    return;
  }
  spinner$1.stop();
  if (file && !outputJson) {
    fs.writeFile(file, JSON.stringify(data), err => {
      err ? console.error(err) : console.log(`Data successfully written to ${file}`);
    });
    return;
  }
  if (outputJson) {
    console.log(`\n Diff scan result: \n`);
    console.log(require$$0$1.inspect(data, {
      showHidden: false,
      depth: null,
      colors: true
    }));
    console.log(`\n View this diff scan in the Socket dashboard: ${colors.cyan(data?.['diff_report_url'])}`);
    return;
  }
  console.log('Diff scan result:');
  console.log(data);
  console.log(`\n  To display the detailed report in the terminal, use the --json flag \n`);
  console.log(`\n View this diff scan in the Socket dashboard: ${colors.cyan(data?.['diff_report_url'])}`);
}

const config$u = {
  commandName: 'get',
  description: 'Get a diff scan for an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    before: {
      type: 'string',
      shortFlag: 'b',
      default: '',
      description: 'The full scan ID of the base scan'
    },
    after: {
      type: 'string',
      shortFlag: 'a',
      default: '',
      description: 'The full scan ID of the head scan'
    },
    preview: {
      type: 'boolean',
      shortFlag: 'p',
      default: true,
      description: 'A boolean flag to persist or not the diff scan result'
    },
    file: {
      type: 'string',
      shortFlag: 'f',
      default: '',
      description: 'Path to a local file where the output should be saved'
    },
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug> --before=<before> --after=<after>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeCorp --before=aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 --after=aaa1aa1a-aaaa-1111-1a1a-1111111a11a1
  `
};
const cmdDiffScanGet = {
  description: config$u.description,
  hidden: config$u.hidden,
  run: run$u
};
async function run$u(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$u,
    importMeta,
    parentName
  });
  const before = String(cli.flags['before'] || '');
  const after = String(cli.flags['after'] || '');
  const [orgSlug = ''] = cli.input;
  if (!before || !after || cli.input.length < 1) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Specify a before and after full scan ID ${!before && !after ? colors.red('(missing before and after!)') : !before ? colors.red('(missing before!)') : !after ? colors.red('(missing after!)') : colors.green('(ok)')}\n
          - To get full scans IDs, you can run the command "socket scan list <your org slug>".
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n}
    `);
    config$u.help(parentName, config$u);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await getDiffScan({
    outputJson: Boolean(cli.flags['json']),
    outputMarkdown: Boolean(cli.flags['markdown']),
    before,
    after,
    preview: Boolean(cli.flags['preview']),
    orgSlug,
    file: String(cli.flags['file'] || '')
  }, apiToken);
}

const description$3 = 'Diff scans related commands';
const cmdDiffScan = {
  description: description$3,
  async run(argv, importMeta, {
    parentName
  }) {
    await meowWithSubcommands({
      get: cmdDiffScanGet
    }, {
      argv,
      description: description$3,
      importMeta,
      name: parentName + ' diff-scan'
    });
  }
};

// import { detect } from '../../utils/package-manager-detector'

const {
  NPM: NPM$d
} = constants;
function isTopLevel(tree, node) {
  return tree.children.get(node.name) === node;
}
async function runFix() {
  const spinner$1 = new spinner.Spinner().start();
  const cwd = process.cwd();
  const editablePkgJson = await packages.readPackageJson(cwd, {
    editable: true
  });
  // const agentDetails = await detect()

  const arb = new index.SafeArborist({
    path: cwd,
    ...index.SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES
  });
  await arb.reify();
  const alerts = await index.getPackagesAlerts(arb, {
    consolidate: true,
    includeExisting: true,
    includeUnfixable: false
  });
  const infoByPkg = index.getCveInfoByPackage(alerts);
  await arb.buildIdealTree();
  if (infoByPkg) {
    for (const {
      0: name,
      1: infos
    } of infoByPkg) {
      let revertToIdealTree = arb.idealTree;
      arb.idealTree = null;
      // eslint-disable-next-line no-await-in-loop
      await arb.buildIdealTree();
      const tree = arb.idealTree;
      const hasUpgrade = !!registry.getManifestData(NPM$d, name);
      if (hasUpgrade) {
        spinner$1.stop();
        console.log(`Skipping ${name}. Socket Optimize package exists.`);
        spinner$1.start();
        continue;
      }
      const nodes = index.findPackageNodes(tree, name);
      const packument = nodes.length && infos.length ?
      // eslint-disable-next-line no-await-in-loop
      await packages.fetchPackagePackument(name) : null;
      if (packument) {
        for (let i = 0, {
            length: nodesLength
          } = nodes; i < nodesLength; i += 1) {
          const node = nodes[i];
          for (let j = 0, {
              length: infosLength
            } = infos; j < infosLength; j += 1) {
            const {
              firstPatchedVersionIdentifier,
              vulnerableVersionRange
            } = infos[j];
            const {
              version: oldVersion
            } = node;
            if (index.updateNode(node, packument, vulnerableVersionRange)) {
              try {
                // eslint-disable-next-line no-await-in-loop
                await npm.runScript('test', [], {
                  stdio: 'pipe'
                });
                spinner$1.info(`Patched ${name} ${oldVersion} -> ${node.version}`);
                spinner$1.start();
                if (isTopLevel(tree, node)) {
                  for (const depField of ['dependencies', 'optionalDependencies', 'peerDependencies']) {
                    const oldVersion = editablePkgJson.content[depField]?.[name];
                    if (oldVersion) {
                      const decorator = /^[~^]/.exec(oldVersion)?.[0] ?? '';
                      editablePkgJson.content[depField][name] = `${decorator}${node.version}`;
                    }
                  }
                }
                // eslint-disable-next-line no-await-in-loop
                await editablePkgJson.save();
              } catch {
                spinner$1.error(`Reverting ${name} to ${oldVersion}`);
                spinner$1.start();
                arb.idealTree = revertToIdealTree;
              }
            } else {
              spinner$1.stop();
              console.log(`Could not patch ${name} ${oldVersion}`);
              spinner$1.start();
            }
          }
        }
      }
    }
  }
  const arb2 = new index.Arborist({
    path: cwd
  });
  arb2.idealTree = arb.idealTree;
  await arb2.reify();
  spinner$1.stop();
}

const config$t = {
  commandName: 'fix',
  description: 'Fix "fixable" Socket alerts',
  hidden: true,
  flags: {},
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}
  `
};
const cmdFix = {
  description: config$t.description,
  hidden: config$t.hidden,
  run: run$t
};
async function run$t(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    argv,
    config: config$t,
    importMeta,
    parentName
  });
  await runFix();
}

function objectSome(obj) {
  for (const key in obj) {
    if (obj[key]) {
      return true;
    }
  }
  return false;
}
function pick(input, keys) {
  const result = {};
  for (const key of keys) {
    result[key] = input[key];
  }
  return result;
}

function stringJoinWithSeparateFinalSeparator(list, separator = ' and ') {
  const values = list.filter(Boolean);
  const {
    length
  } = values;
  if (!length) {
    return '';
  }
  if (length === 1) {
    return values[0];
  }
  const finalValue = values.pop();
  return `${values.join(', ')}${separator}${finalValue}`;
}

// Ordered from most severe to least.
const SEVERITIES_BY_ORDER = ['critical', 'high', 'middle', 'low'];
function getDesiredSeverities(lowestToInclude) {
  const result = [];
  for (const severity of SEVERITIES_BY_ORDER) {
    result.push(severity);
    if (severity === lowestToInclude) {
      break;
    }
  }
  return result;
}
function formatSeverityCount(severityCount) {
  const summary = [];
  for (const severity of SEVERITIES_BY_ORDER) {
    if (severityCount[severity]) {
      summary.push(`${severityCount[severity]} ${severity}`);
    }
  }
  return stringJoinWithSeparateFinalSeparator(summary);
}
function getSeverityCount(issues, lowestToInclude) {
  const severityCount = pick({
    low: 0,
    middle: 0,
    high: 0,
    critical: 0
  }, getDesiredSeverities(lowestToInclude));
  for (const issue of issues) {
    const {
      value
    } = issue;
    if (!value) {
      continue;
    }
    if (severityCount[value.severity] !== undefined) {
      severityCount[value.severity] += 1;
    }
  }
  return severityCount;
}

async function fetchPackageInfo(pkgName, pkgVersion, includeAllIssues, spinner) {
  const socketSdk = await index.setupSdk(index.getPublicToken());
  const result = await handleApiCall(socketSdk.getIssuesByNPMPackage(pkgName, pkgVersion), 'looking up package');
  const scoreResult = await handleApiCall(socketSdk.getScoreByNPMPackage(pkgName, pkgVersion), 'looking up package score');
  if (result.success === false) {
    return handleUnsuccessfulApiResponse('getIssuesByNPMPackage', result, spinner);
  }
  if (scoreResult.success === false) {
    return handleUnsuccessfulApiResponse('getScoreByNPMPackage', scoreResult, spinner);
  }
  const severityCount = getSeverityCount(result.data, includeAllIssues ? undefined : 'high');
  return {
    data: result.data,
    severityCount,
    score: scoreResult.data
  };
}

const {
  NPM: NPM$c
} = registryConstants;
function formatPackageInfo({
  data,
  score,
  severityCount
}, {
  name,
  outputJson,
  outputMarkdown,
  pkgName,
  pkgVersion,
  strict
}, spinner) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
  } else {
    console.log('\nPackage report card:');
    const scoreResult = {
      'Supply Chain Risk': Math.floor(score.supplyChainRisk.score * 100),
      Maintenance: Math.floor(score.maintenance.score * 100),
      Quality: Math.floor(score.quality.score * 100),
      Vulnerabilities: Math.floor(score.vulnerability.score * 100),
      License: Math.floor(score.license.score * 100)
    };
    Object.entries(scoreResult).map(score => console.log(`- ${score[0]}: ${formatScore(score[1])}`));
    console.log('\n');
    if (objectSome(severityCount)) {
      spinner[strict ? 'error' : 'success'](`Package has these issues: ${formatSeverityCount(severityCount)}`);
      formatPackageIssuesDetails(data, outputMarkdown);
    } else {
      spinner.success('Package has no issues');
    }
    const format = new index.ColorOrMarkdown(!!outputMarkdown);
    const url = index.getSocketDevPackageOverviewUrl(NPM$c, pkgName, pkgVersion);
    console.log('\n');
    if (pkgVersion === 'latest') {
      console.log(`Detailed info on socket.dev: ${format.hyperlink(`${pkgName}`, url, {
        fallbackToUrl: true
      })}`);
    } else {
      console.log(`Detailed info on socket.dev: ${format.hyperlink(`${pkgName} v${pkgVersion}`, url, {
        fallbackToUrl: true
      })}`);
    }
    if (!outputMarkdown) {
      console.log(colors.dim(`\nOr rerun ${colors.italic(name)} using the ${colors.italic('--json')} flag to get full JSON output`));
    }
  }
  if (strict && objectSome(severityCount)) {
    process$1.exit(1);
  }
}
function formatPackageIssuesDetails(packageData, outputMarkdown) {
  const issueDetails = packageData.filter(d => d.value?.severity === 'high' || d.value?.severity === 'critical');
  const uniqueIssues = issueDetails.reduce((acc, issue) => {
    const {
      type
    } = issue;
    if (type) {
      if (acc[type] === undefined) {
        acc[type] = {
          label: issue.value?.label,
          count: 1
        };
      } else {
        acc[type].count += 1;
      }
    }
    return acc;
  }, {});
  const format = new index.ColorOrMarkdown(!!outputMarkdown);
  for (const issue of Object.keys(uniqueIssues)) {
    const issueWithLink = format.hyperlink(`${uniqueIssues[issue]?.label}`, index.getSocketDevAlertUrl(issue), {
      fallbackToUrl: true
    });
    if (uniqueIssues[issue]?.count === 1) {
      console.log(`- ${issueWithLink}`);
    } else {
      console.log(`- ${issueWithLink}: ${uniqueIssues[issue]?.count}`);
    }
  }
}
function formatScore(score) {
  if (score > 80) {
    return colors.green(`${score}`);
  } else if (score < 80 && score > 60) {
    return colors.yellow(`${score}`);
  }
  return colors.red(`${score}`);
}

async function getPackageInfo({
  commandName,
  includeAllIssues,
  outputJson,
  outputMarkdown,
  pkgName,
  pkgVersion,
  strict
}) {
  const spinnerText = pkgVersion === 'latest' ? `Looking up data for the latest version of ${pkgName}` : `Looking up data for version ${pkgVersion} of ${pkgName}`;
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const packageData = await fetchPackageInfo(pkgName, pkgVersion, includeAllIssues, spinner$1);
  if (packageData) {
    formatPackageInfo(packageData, {
      name: commandName,
      outputJson,
      outputMarkdown,
      pkgName,
      pkgVersion,
      strict
    }, spinner$1);
  }
}

const config$s = {
  commandName: 'info',
  description: 'Look up info regarding a package',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <name>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} webtorrent
      $ ${command} webtorrent@1.9.1
  `
};
const cmdInfo = {
  description: config$s.description,
  hidden: config$s.hidden,
  run: run$s
};
async function run$s(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$s,
    importMeta,
    parentName
  });
  if (cli.input.length > 1) {
    throw new index.InputError('Only one package lookup supported at once');
  }
  const {
    0: rawPkgName = ''
  } = cli.input;
  let showHelp = cli.flags['help'];
  if (!rawPkgName) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const versionSeparator = rawPkgName.lastIndexOf('@');
  const pkgName = versionSeparator < 1 ? rawPkgName : rawPkgName.slice(0, versionSeparator);
  const pkgVersion = versionSeparator < 1 ? 'latest' : rawPkgName.slice(versionSeparator + 1);
  await getPackageInfo({
    commandName: `${parentName} ${config$s.commandName}`,
    includeAllIssues: Boolean(cli.flags['all']),
    outputJson: Boolean(cli.flags['json']),
    outputMarkdown: Boolean(cli.flags['markdown']),
    pkgName,
    pkgVersion,
    strict: Boolean(cli.flags['strict'])
  });
}

function applyLogin(apiToken, enforcedOrgs, apiBaseUrl, apiProxy) {
  index.updateSetting('enforcedOrgs', enforcedOrgs);
  index.updateSetting('apiToken', apiToken);
  index.updateSetting('apiBaseUrl', apiBaseUrl);
  index.updateSetting('apiProxy', apiProxy);
}

// TODO: this type should come from a general Socket REST API type doc

const {
  SOCKET_PUBLIC_API_TOKEN
} = constants;
async function attemptLogin(apiBaseUrl, apiProxy) {
  const apiToken = (await prompts.password({
    message: `Enter your ${terminalLink('Socket.dev API key', 'https://docs.socket.dev/docs/api-keys')} (leave blank for a public key)`
  })) || SOCKET_PUBLIC_API_TOKEN;
  apiBaseUrl ??= index.getSetting('apiBaseUrl') ?? undefined;
  apiProxy ??= index.getSetting('apiProxy') ?? undefined;
  const spinner$1 = new spinner.Spinner({
    text: 'Verifying API key...'
  }).start();
  let orgs;
  try {
    const sdk = await index.setupSdk(apiToken, apiBaseUrl, apiProxy);
    const result = await sdk.getOrganizations();
    if (!result.success) {
      throw new index.AuthError();
    }
    orgs = result.data;
    spinner$1.success('API key verified');
  } catch {
    spinner$1.error('Invalid API key');
    return;
  }
  const enforcedChoices = Object.values(orgs.organizations).filter(org => org?.plan === 'enterprise').map(org => ({
    name: org.name,
    value: org.id
  }));
  let enforcedOrgs = [];
  if (enforcedChoices.length > 1) {
    const id = await prompts.select({
      message: "Which organization's policies should Socket enforce system-wide?",
      choices: enforcedChoices.concat({
        name: 'None',
        value: '',
        description: 'Pick "None" if this is a personal device'
      })
    });
    if (id) {
      enforcedOrgs = [id];
    }
  } else if (enforcedChoices.length) {
    const confirmOrg = await prompts.confirm({
      message: `Should Socket enforce ${enforcedChoices[0]?.name}'s security policies system-wide?`,
      default: true
    });
    if (confirmOrg) {
      const existing = enforcedChoices[0];
      if (existing) {
        enforcedOrgs = [existing.value];
      }
    }
  }
  const oldToken = index.getSetting('apiToken');
  try {
    applyLogin(apiToken, enforcedOrgs, apiBaseUrl, apiProxy);
    spinner$1.success(`API credentials ${oldToken ? 'updated' : 'set'}`);
  } catch {
    spinner$1.error(`API login failed`);
  }
}

const config$r = {
  commandName: 'login',
  description: 'Socket API login',
  hidden: false,
  flags: {
    apiBaseUrl: {
      type: 'string',
      description: 'API server to connect to for login'
    },
    apiProxy: {
      type: 'string',
      description: 'Proxy to use when making connection to API server'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Logs into the Socket API by prompting for an API key

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}
      $ ${command} --api-proxy=http://localhost:1234
  `
};
const cmdLogin = {
  description: config$r.description,
  hidden: config$r.hidden,
  run: run$r
};
async function run$r(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$r,
    importMeta,
    parentName
  });
  if (!isInteractive()) {
    throw new index.InputError('Cannot prompt for credentials in a non-interactive shell');
  }
  let apiBaseUrl = cli.flags['apiBaseUrl'];
  let apiProxy = cli.flags['apiProxy'];
  await attemptLogin(apiBaseUrl, apiProxy);
}

function applyLogout() {
  index.updateSetting('apiToken', null);
  index.updateSetting('apiBaseUrl', null);
  index.updateSetting('apiProxy', null);
  index.updateSetting('enforcedOrgs', null);
}

function attemptLogout() {
  try {
    applyLogout();
    new spinner.Spinner().success('Successfully logged out');
  } catch {
    new spinner.Spinner().success('Failed to complete logout steps');
  }
}

const config$q = {
  commandName: 'logout',
  description: 'Socket API logout',
  hidden: false,
  flags: {},
  help: (command, _config) => `
    Usage
      $ ${command}

    Logs out of the Socket API and clears all Socket credentials from disk
  `
};
const cmdLogout = {
  description: config$q.description,
  hidden: config$q.hidden,
  run: run$q
};
async function run$q(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    argv,
    config: config$q,
    importMeta,
    parentName
  });
  attemptLogout();
}

async function convertGradleToMaven(target, bin, _out, verbose, gradleOpts) {
  const rbin = path.resolve(bin);
  const rtarget = path.resolve(target);
  // const rout = out === '-' ? '-' : path.resolve(out)

  if (verbose) {
    console.group('gradle2maven:');
    console.log(`[VERBOSE] - Absolute bin path: \`${rbin}\``);
    console.log(`[VERBOSE] - Absolute target path: \`${rtarget}\``);
    // console.log(`[VERBOSE] - Absolute out path: \`${rout}\``)
    console.groupEnd();
  } else {
    console.group('gradle2maven:');
    console.log(`- executing: \`${bin}\``);
    console.log(`- src dir: \`${target}\``);
    // console.log(`- dst dir: \`${out}\``)
    console.groupEnd();
  }
  const spinner$1 = new spinner.Spinner();
  spinner$1.start(`Converting gradle to maven from \`${bin}\` on \`${target}\`...`);
  try {
    // Run sbt with the init script we provide which should yield zero or more pom files.
    // We have to figure out where to store those pom files such that we can upload them and predict them through the GitHub API.
    // We could do a .socket folder. We could do a socket.pom.gz with all the poms, although I'd prefer something plain-text if it is to be committed.

    // Note: init.gradle will be exported by .config/rollup.dist.config.mjs
    const initLocation = path.join(constants.rootDistPath, 'init.gradle');
    const commandArgs = ['--init-script', initLocation, ...gradleOpts, 'pom'];
    if (verbose) {
      console.log('\n[VERBOSE] Executing:', bin, commandArgs);
    }
    const output = await spawn(bin, commandArgs, {
      cwd: target || '.'
    });
    spinner$1.success();
    if (verbose) {
      console.group('[VERBOSE] gradle stdout:');
      console.log(output);
      console.groupEnd();
    }
    if (output.stderr) {
      spinner$1.error('There were errors while running gradle');
      // (In verbose mode, stderr was printed above, no need to repeat it)
      if (!verbose) {
        console.group('[VERBOSE] stderr:');
        console.error(output.stderr);
        console.groupEnd();
      }
      process.exit(1);
    }
    console.log('Reported exports:');
    output.stdout.replace(/^POM file copied to: (.*)/gm, (_all, fn) => {
      console.log('- ', fn);
      return fn;
    });

    // const loc = output.stdout?.match(/Wrote (.*?.pom)\n/)?.[1]?.trim()
    // if (!loc) {
    //   spinner.error(
    //     'There were no errors from sbt but could not find the location of resulting .pom file either'
    //   )
    //   process.exit(1)
    // }
    //
    // // Move the pom file to ...? initial cwd? loc will be an absolute path, or dump to stdout
    // if (out === '-') {
    //   spinner.start('Result:\n```').success()
    //   console.log(await safeReadFile(loc, 'utf8'))
    //   console.log('```')
    //   spinner.start().success(`OK`)
    // } else {
    //   if (verbose) {
    //     spinner.start(
    //       `Moving manifest file from \`${loc.replace(/^\/home\/[^/]*?\//, '~/')}\` to \`${out}\``
    //     )
    //   } else {
    //     spinner.start('Moving output pom file')
    //   }
    //   // TODO: do we prefer fs-extra? renaming can be gnarly on windows and fs-extra's version is better
    //   await renamep(loc, out)
    //   spinner.success()
    //   spinner.start().success(`OK. File should be available in \`${out}\``)
    // }
  } catch (e) {
    spinner$1.error('There was an unexpected error while running this' + (verbose ? '' : ' (use --verbose for details)'));
    if (verbose) {
      console.group('[VERBOSE] error:');
      console.log(e);
      console.groupEnd();
    }
    process.exit(1);
  }
}

const config$p = {
  commandName: 'gradle',
  description: '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Gradle/Java/Kotlin/etc project',
  hidden: false,
  flags: {
    ...commonFlags,
    bin: {
      type: 'string',
      description: 'Location of gradlew binary to use, default: CWD/gradlew'
    },
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    gradleOpts: {
      type: 'string',
      default: '',
      description: 'Additional options to pass on to ./gradlew, see `./gradlew --help`'
    },
    out: {
      type: 'string',
      default: './socket.pom.xml',
      description: 'Path of output file; where to store the resulting manifest, see also --stdout'
    },
    stdout: {
      type: 'boolean',
      description: 'Print resulting pom.xml to stdout (supersedes --out)'
    },
    task: {
      type: 'string',
      default: 'all',
      description: 'Task to target. By default targets all.'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [--gradle=path/to/gradle/binary] [--out=path/to/result] DIR

    Options
      ${getFlagListOutput(config.flags, 6)}

    Uses gradle, preferably through your local project \`gradlew\`, to generate a
    \`pom.xml\` file for each task. If you have no \`gradlew\` you can try the
    global \`gradle\` binary but that may not work (hard to predict).

    The \`pom.xml\` is a manifest file similar to \`package.json\` for npm or
    or requirements.txt for PyPi), but specifically for Maven, which is Java's
    dependency repository. Languages like Kotlin and Scala piggy back on it too.

    There are some caveats with the gradle to \`pom.xml\` conversion:

    - each task will generate its own xml file and by default it generates one xml
      for every task.

    - it's possible certain features don't translate well into the xml. If you
      think something is missing that could be supported please reach out.

    - it works with your \`gradlew\` from your repo and local settings and config

    Support is beta. Please report issues or give us feedback on what's missing.

    Examples

      $ ${command} .
      $ ${command} --gradlew=../gradlew .
  `
};
const cmdManifestGradle = {
  description: config$p.description,
  hidden: config$p.hidden,
  run: run$p
};
async function run$p(argv, importMeta, {
  parentName
}) {
  // note: meow will exit if it prints the --help screen
  const cli = vendor.meow(config$p.help(parentName, config$p), {
    flags: config$p.flags,
    argv: argv.length === 0 ? ['--help'] : argv,
    description: config$p.description,
    allowUnknownFlags: false,
    importMeta
  });
  const verbose = Boolean(cli.flags['verbose']);
  if (verbose) {
    console.group('- ', parentName, config$p.commandName, ':');
    console.group('- flags:', cli.flags);
    console.groupEnd();
    console.log('- input:', cli.input);
    console.groupEnd();
  }
  const target = cli.input[0];
  if (!target) {
    // will exit.
    new spinner.Spinner().start('Parsing...').error(`Failure: Missing DIR argument. See \`${parentName} ${config$p.commandName} --help\` for details.`);
    process.exit(1);
  }
  if (cli.input.length > 1) {
    // will exit.
    new spinner.Spinner().start('Parsing...').error(`Failure: Can only accept one FILE or DIR, received ${cli.input.length} (make sure to escape spaces!). See \`${parentName} ${config$p.commandName} --help\` for details.`);
    process.exit(1);
  }
  let bin;
  if (cli.flags['bin']) {
    bin = cli.flags['bin'];
  } else {
    bin = path.join(target, 'gradlew');
  }
  let out = './socket.pom.xml';
  if (cli.flags['out']) {
    out = cli.flags['out'];
  }
  if (cli.flags['stdout']) {
    out = '-';
  }

  // TODO: I'm not sure it's feasible to parse source file from stdin. We could try, store contents in a file in some folder, target that folder... what would the file name be?
  if (target === '-') {
    new spinner.Spinner().start('Parsing...').error(`Failure: Currently source code from stdin is not supported. See \`${parentName} ${config$p.commandName} --help\` for details.`);
    process.exit(1);
  }
  if (verbose) {
    console.group();
    console.log('- target:', target);
    console.log('- gradle bin:', bin);
    console.log('- out:', out);
    console.groupEnd();
  }
  let gradleOpts = [];
  if (cli.flags['gradleOpts']) {
    gradleOpts = cli.flags['gradleOpts'].split(' ').map(s => s.trim()).filter(Boolean);
  }
  await convertGradleToMaven(target, bin, out, verbose, gradleOpts);
}

async function convertSbtToMaven(target, bin, out, verbose, sbtOpts) {
  const rbin = path.resolve(bin);
  const rtarget = path.resolve(target);
  // const rout = out === '-' ? '-' : path.resolve(out)

  if (verbose) {
    console.group('sbt2maven:');
    console.log(`[VERBOSE] - Absolute bin path: \`${rbin}\``);
    console.log(`[VERBOSE] - Absolute target path: \`${rtarget}\``);
    // console.log(`[VERBOSE] - Absolute out path: \`${rout}\``)
    console.groupEnd();
  } else {
    console.group('sbt2maven:');
    console.log(`- executing: \`${bin}\``);
    console.log(`- src dir: \`${target}\``);
    // console.log(`- dst dir: \`${out}\``)
    console.groupEnd();
  }
  const spinner$1 = new spinner.Spinner();
  spinner$1.start(`Converting sbt to maven from \`${bin}\` on \`${target}\`...`);
  try {
    // Run sbt with the init script we provide which should yield zero or more pom files.
    // We have to figure out where to store those pom files such that we can upload them and predict them through the GitHub API.
    // We could do a .socket folder. We could do a socket.pom.gz with all the poms, although I'd prefer something plain-text if it is to be committed.

    const output = await spawn(bin, ['makePom'].concat(sbtOpts), {
      cwd: target || '.'
    });
    spinner$1.success();
    if (verbose) {
      console.group('[VERBOSE] sbt stdout:');
      console.log(output);
      console.groupEnd();
    }
    if (output.stderr) {
      spinner$1.error('There were errors while running sbt');
      // (In verbose mode, stderr was printed above, no need to repeat it)
      if (!verbose) {
        console.group('[VERBOSE] stderr:');
        console.error(output.stderr);
        console.groupEnd();
      }
      process.exit(1);
    }
    const poms = [];
    output.stdout.replace(/Wrote (.*?.pom)\n/g, (_all, fn) => {
      poms.push(fn);
      return fn;
    });
    if (!poms.length) {
      spinner$1.error('There were no errors from sbt but it seems to not have generated any poms either');
      process.exit(1);
    }

    // Move the pom file to ...? initial cwd? loc will be an absolute path, or dump to stdout
    // TODO: what to do with multiple output files? Do we want to dump them to stdout? Raw or with separators or ?
    // TODO: maybe we can add an option to target a specific file to dump to stdout
    if (out === '-' && poms.length === 1) {
      spinner$1.start('Result:\n```').success();
      console.log(await index.safeReadFile(poms[0], 'utf8'));
      console.log('```');
      spinner$1.start().success(`OK`);
    } else if (out === '-') {
      spinner$1.start().error('Requested out target was stdout but there are multiple generated files');
      poms.forEach(fn => console.error('-', fn));
      console.error('Exiting now...');
      process.exit(1);
    } else {
      // if (verbose) {
      //   spinner.start(
      //     `Moving manifest file from \`${loc.replace(/^\/home\/[^/]*?\//, '~/')}\` to \`${out}\``
      //   )
      // } else {
      //   spinner.start('Moving output pom file')
      // }
      // TODO: do we prefer fs-extra? renaming can be gnarly on windows and fs-extra's version is better
      // await renamep(loc, out)
      spinner$1.start().success(`Generated ${poms.length} pom files`);
      poms.forEach(fn => console.log('-', fn));
      spinner$1.start().success(`OK`);
    }
  } catch (e) {
    spinner$1.error('There was an unexpected error while running this' + (verbose ? '' : ' (use --verbose for details)'));
    if (verbose) {
      console.group('[VERBOSE] error:');
      console.log(e);
      console.groupEnd();
    }
    process.exit(1);
  }
}

const config$o = {
  commandName: 'kotlin',
  description: "[beta] Generate a manifest file (`pom.xml`) from Scala's `build.sbt` file",
  hidden: false,
  flags: {
    ...commonFlags,
    bin: {
      type: 'string',
      default: 'sbt',
      description: 'Location of sbt binary to use'
    },
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    out: {
      type: 'string',
      default: './socket.pom.xml',
      description: 'Path of output file; where to store the resulting manifest, see also --stdout'
    },
    stdout: {
      type: 'boolean',
      description: 'Print resulting pom.xml to stdout (supersedes --out)'
    },
    sbtOpts: {
      type: 'string',
      default: '',
      description: 'Additional options to pass on to sbt, as per `sbt --help`'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [--sbt=path/to/sbt/binary] [--out=path/to/result] FILE|DIR

    Options
      ${getFlagListOutput(config.flags, 6)}

    Uses \`sbt makePom\` to generate a \`pom.xml\` from your \`build.sbt\` file.
    This xml file is the dependency manifest (like a package.json
    for Node.js or requirements.txt for PyPi), but specifically for Scala.

    There are some caveats with \`build.sbt\` to \`pom.xml\` conversion:

    - the xml is exported as socket.pom.xml as to not confuse existing build tools
      but it will first hit your /target/sbt<version> folder (as a different name)

    - the pom.xml format (standard by Scala) does not support certain sbt features
      - \`excludeAll()\`, \`dependencyOverrides\`, \`force()\`, \`relativePath\`
      - For details: https://www.scala-sbt.org/1.x/docs/Library-Management.html

    - it uses your sbt settings and local configuration verbatim

    - it can only export one target per run, so if you have multiple targets like
      development and production, you must run them separately.

    You can optionally configure the path to the \`sbt\` bin to invoke.

    Support is beta. Please report issues or give us feedback on what's missing.

    Examples

      $ ${command} ./build.sbt
      $ ${command} --bin=/usr/bin/sbt ./build.sbt
  `
};
const cmdManifestScala = {
  description: config$o.description,
  hidden: config$o.hidden,
  run: run$o
};
async function run$o(argv, importMeta, {
  parentName
}) {
  // console.log('scala', argv, parentName)
  // note: meow will exit if it prints the --help screen
  const cli = vendor.meow(config$o.help(parentName, config$o), {
    flags: config$o.flags,
    argv: argv.length === 0 ? ['--help'] : argv,
    description: config$o.description,
    allowUnknownFlags: false,
    importMeta
  });
  const verbose = Boolean(cli.flags['verbose']);
  if (verbose) {
    console.group('- ', parentName, config$o.commandName, ':');
    console.group('- flags:', cli.flags);
    console.groupEnd();
    console.log('- input:', cli.input);
    console.groupEnd();
  }
  const target = cli.input[0];
  if (!target) {
    // will exit.
    new spinner.Spinner().start('Parsing...').error(`Failure: Missing FILE|DIR argument. See \`${parentName} ${config$o.commandName} --help\` for details.`);
    process.exit(1);
  }
  if (cli.input.length > 1) {
    // will exit.
    new spinner.Spinner().start('Parsing...').error(`Failure: Can only accept one FILE or DIR, received ${cli.input.length} (make sure to escape spaces!). See \`${parentName} ${config$o.commandName} --help\` for details.`);
    process.exit(1);
  }
  let bin = 'sbt';
  if (cli.flags['bin']) {
    bin = cli.flags['bin'];
  }
  let out = './socket.pom.xml';
  if (cli.flags['out']) {
    out = cli.flags['out'];
  }
  if (cli.flags['stdout']) {
    out = '-';
  }
  if (verbose) {
    console.group();
    console.log('- target:', target);
    console.log('- gradle bin:', bin);
    console.log('- out:', out);
    console.groupEnd();
  }

  // TODO: we can make `-` (accept from stdin) work by storing it into /tmp
  if (target === '-') {
    new spinner.Spinner().start('Parsing...').error(`Failure: Currently source code from stdin is not supported. See \`${parentName} ${config$o.commandName} --help\` for details.`);
    process.exit(1);
  }
  let sbtOpts = [];
  if (cli.flags['sbtOpts']) {
    sbtOpts = cli.flags['sbtOpts'].split(' ').map(s => s.trim()).filter(Boolean);
  }
  await convertSbtToMaven(target, bin, out, verbose, sbtOpts);
}

const config$n = {
  commandName: 'auto',
  description: 'Auto-detect build and attempt to generate manifest file',
  hidden: false,
  flags: {
    ...commonFlags,
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    verbose: {
      type: 'boolean',
      default: false,
      description: 'Enable debug output, may help when running into errors'
    }
    // TODO: support output flags
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}

    Tries to figure out what language your current repo uses. If it finds a
    supported case then it will try to generate the manifest file for that
    language with the default or detected settings.
  `
};
const cmdManifestAuto = {
  description: config$n.description,
  hidden: config$n.hidden,
  run: run$n
};
async function run$n(argv, importMeta, {
  parentName
}) {
  const cli = vendor.meow(config$n.help(parentName, config$n), {
    argv,
    description: config$n.description,
    importMeta,
    flags: config$n.flags,
    allowUnknownFlags: false
  });
  const verbose = !!cli.flags['verbose'];
  const cwd = cli.flags['cwd'] ?? process.cwd();
  if (verbose) {
    console.group('- ', parentName, config$n.commandName, ':');
    console.group('- flags:', cli.flags);
    console.groupEnd();
    console.log('- input:', cli.input);
    console.log('- cwd:', cwd);
    console.groupEnd();
  }
  const subArgs = [];
  if (verbose) {
    subArgs.push('--verbose');
  }
  const dir = cwd;
  if (fs.existsSync(path.join(dir, 'build.sbt'))) {
    console.log('Detected a Scala sbt build, running default Scala generator...');
    if (cwd) {
      subArgs.push('--cwd', cwd);
    }
    subArgs.push(dir);
    await cmdManifestScala.run(subArgs, importMeta, {
      parentName
    });
    return;
  }
  if (fs.existsSync(path.join(dir, 'gradlew'))) {
    console.log('Detected a gradle build, running default gradle generator...');
    if (cwd) {
      // This command takes the cwd as first arg.
      subArgs.push(cwd);
    }
    await cmdManifestGradle.run(subArgs, importMeta, {
      parentName
    });
    return;
  }
  // Show new help screen and exit.
  vendor.meow(`
    $ ${parentName} ${config$n.commandName}

    Unfortunately this script did not discover a supported language in the
    current folder.

    - Make sure this script would work with your target build
    - Make sure to run it from the correct folder
    - Make sure the necessary build tools are available (\`PATH\`)

    If that doesn't work, see \`${parentName} <lang> --help\` for config details for
    your target language.
  `, {
    argv: [],
    description: config$n.description,
    importMeta
  }).showHelp();
}

// TODO: we may want to dedupe some pieces for all gradle languages. I think it
//       makes sense to have separate commands for them and I think it makes
//       sense for the help panels to note the requested language, rather than
//       `socket manifest kotlin` to print help screens with `gradle` as the
//       command. Room for improvement.
const config$m = {
  commandName: 'kotlin',
  description: '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Kotlin project',
  hidden: false,
  flags: {
    ...commonFlags,
    bin: {
      type: 'string',
      description: 'Location of gradlew binary to use, default: CWD/gradlew'
    },
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    gradleOpts: {
      type: 'string',
      default: '',
      description: 'Additional options to pass on to ./gradlew, see `./gradlew --help`'
    },
    out: {
      type: 'string',
      default: './socket.pom.xml',
      description: 'Path of output file; where to store the resulting manifest, see also --stdout'
    },
    stdout: {
      type: 'boolean',
      description: 'Print resulting pom.xml to stdout (supersedes --out)'
    },
    task: {
      type: 'string',
      default: 'all',
      description: 'Task to target. By default targets all.'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [--gradle=path/to/gradle/binary] [--out=path/to/result] DIR

    Options
      ${getFlagListOutput(config.flags, 6)}

    Uses gradle, preferably through your local project \`gradlew\`, to generate a
    \`pom.xml\` file for each task. If you have no \`gradlew\` you can try the
    global \`gradle\` binary but that may not work (hard to predict).

    The \`pom.xml\` is a manifest file similar to \`package.json\` for npm or
    or requirements.txt for PyPi), but specifically for Maven, which is Java's
    dependency repository. Languages like Kotlin and Scala piggy back on it too.

    There are some caveats with the gradle to \`pom.xml\` conversion:

    - each task will generate its own xml file and by default it generates one xml
      for every task. (This may be a good thing!)

    - it's possible certain features don't translate well into the xml. If you
      think something is missing that could be supported please reach out.

    - it works with your \`gradlew\` from your repo and local settings and config

    Support is beta. Please report issues or give us feedback on what's missing.

    Examples

      $ ${command} .
      $ ${command} --gradlew=../gradlew .
  `
};
const cmdManifestKotlin = {
  description: config$m.description,
  hidden: config$m.hidden,
  run: run$m
};
async function run$m(argv, importMeta, {
  parentName
}) {
  // note: meow will exit if it prints the --help screen
  const cli = vendor.meow(config$m.help(parentName, config$m), {
    flags: config$m.flags,
    argv: argv.length === 0 ? ['--help'] : argv,
    description: config$m.description,
    allowUnknownFlags: false,
    importMeta
  });
  const verbose = Boolean(cli.flags['verbose']);
  if (verbose) {
    console.group('- ', parentName, config$m.commandName, ':');
    console.group('- flags:', cli.flags);
    console.groupEnd();
    console.log('- input:', cli.input);
    console.groupEnd();
  }
  const target = cli.input[0];
  if (!target) {
    // will exit.
    new spinner.Spinner().start('Parsing...').error(`Failure: Missing DIR argument. See \`${parentName} ${config$m.commandName} --help\` for details.`);
    process.exit(1);
  }
  if (cli.input.length > 1) {
    // will exit.
    new spinner.Spinner().start('Parsing...').error(`Failure: Can only accept one FILE or DIR, received ${cli.input.length} (make sure to escape spaces!). See \`${parentName} ${config$m.commandName} --help\` for details.`);
    process.exit(1);
  }
  let bin;
  if (cli.flags['bin']) {
    bin = cli.flags['bin'];
  } else {
    bin = path.join(target, 'gradlew');
  }
  let out = './socket.pom.xml';
  if (cli.flags['out']) {
    out = cli.flags['out'];
  }
  if (cli.flags['stdout']) {
    out = '-';
  }

  // TODO: I'm not sure it's feasible to parse source file from stdin. We could try, store contents in a file in some folder, target that folder... what would the file name be?
  if (target === '-') {
    new spinner.Spinner().start('Parsing...').error(`Failure: Currently source code from stdin is not supported. See \`${parentName} ${config$m.commandName} --help\` for details.`);
    process.exit(1);
  }
  if (verbose) {
    console.group();
    console.log('- target:', target);
    console.log('- gradle bin:', bin);
    console.log('- out:', out);
    console.groupEnd();
  }
  let gradleOpts = [];
  if (cli.flags['gradleOpts']) {
    gradleOpts = cli.flags['gradleOpts'].split(' ').map(s => s.trim()).filter(Boolean);
  }
  await convertGradleToMaven(target, bin, out, verbose, gradleOpts);
}

const config$l = {
  commandName: 'manifest',
  description: 'Generate a dependency manifest for given file or dir',
  hidden: false,
  flags: {
    ...commonFlags
  }};
const cmdManifest = {
  description: config$l.description,
  hidden: config$l.hidden,
  run: run$l
};
async function run$l(argv, importMeta, {
  parentName
}) {
  await meowWithSubcommands({
    auto: cmdManifestAuto,
    scala: cmdManifestScala,
    gradle: cmdManifestGradle,
    kotlin: cmdManifestKotlin
  }, {
    argv,
    aliases: {
      yolo: {
        description: config$l.description,
        hidden: true,
        argv: ['auto']
      }
    },
    description: config$l.description,
    importMeta,
    flags: config$l.flags,
    name: `${parentName} ${config$l.commandName}`
  });
}

const {
  NPM: NPM$b,
  SHADOW_BIN: SHADOW_BIN$1
} = constants;
async function wrapNpm(argv) {
  // Lazily access constants.distPath.
  const shadowBin = require(`${constants.distPath}/${SHADOW_BIN$1}.js`);
  await shadowBin(NPM$b, argv);
}

const {
  NPM: NPM$a
} = constants;
const config$k = {
  commandName: 'npm',
  description: `${NPM$a} wrapper functionality`,
  hidden: false,
  flags: {},
  help: (command, _config) => `
    Usage
      $ ${command}
  `
};
const cmdNpm = {
  description: config$k.description,
  hidden: config$k.hidden,
  run: run$k
};
async function run$k(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$k,
    importMeta,
    parentName
  });
  await wrapNpm(argv);
}

const {
  NPX: NPX$2,
  SHADOW_BIN
} = constants;
async function wrapNpx(argv) {
  // Lazily access constants.distPath.
  const shadowBin = require(`${constants.distPath}/${SHADOW_BIN}.js`);
  await shadowBin(NPX$2, argv);
}

const {
  NPX: NPX$1
} = constants;
const config$j = {
  commandName: 'npx',
  description: `${NPX$1} wrapper functionality`,
  hidden: false,
  flags: {},
  help: (command, _config) => `
    Usage
      $ ${command}
  `
};
const cmdNpx = {
  description: config$j.description,
  hidden: config$j.hidden,
  run: run$j
};
async function run$j(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$j,
    importMeta,
    parentName
  });
  await wrapNpx(argv);
}

const config$i = {
  commandName: 'oops',
  description: 'Trigger an intentional error (for development)',
  hidden: true,
  flags: {},
  help: (parentName, config) => `
    Usage
      $ ${parentName} ${config.commandName}

    Don't run me.
  `
};
const cmdOops = {
  description: config$i.description,
  hidden: config$i.hidden,
  run: run$i
};
async function run$i(argv, importMeta, {
  parentName
}) {
  vendor.meow(config$i.help(parentName, config$i), {
    argv,
    description: config$i.description,
    importMeta,
    flags: config$i.flags
  });
  throw new Error('This error was intentionally left blank');
}

const {
  BUN: BUN$6,
  NPM: NPM$9,
  PNPM: PNPM$7,
  VLT: VLT$6,
  YARN_BERRY: YARN_BERRY$6,
  YARN_CLASSIC: YARN_CLASSIC$6
} = constants;
function matchHumanStdout(stdout, name) {
  return stdout.includes(` ${name}@`);
}
function matchQueryStdout(stdout, name) {
  return stdout.includes(`"${name}"`);
}
const depsIncludesByAgent = {
  // @ts-ignore
  __proto__: null,
  [BUN$6]: matchHumanStdout,
  [NPM$9]: matchQueryStdout,
  [PNPM$7]: matchQueryStdout,
  [VLT$6]: matchQueryStdout,
  [YARN_BERRY$6]: matchHumanStdout,
  [YARN_CLASSIC$6]: matchHumanStdout
};

const {
  BINARY_LOCK_EXT,
  BUN: BUN$5,
  LOCK_EXT: LOCK_EXT$1,
  NPM: NPM$8,
  PNPM: PNPM$6,
  VLT: VLT$5,
  YARN,
  YARN_BERRY: YARN_BERRY$5,
  YARN_CLASSIC: YARN_CLASSIC$5
} = constants;
const AGENTS = [BUN$5, NPM$8, PNPM$6, YARN_BERRY$5, YARN_CLASSIC$5, VLT$5];
const binByAgent = {
  __proto__: null,
  [BUN$5]: BUN$5,
  [NPM$8]: NPM$8,
  [PNPM$6]: PNPM$6,
  [YARN_BERRY$5]: YARN,
  [YARN_CLASSIC$5]: YARN,
  [VLT$5]: VLT$5
};
async function getAgentExecPath(agent) {
  const binName = binByAgent[agent];
  return (await which(binName, {
    nothrow: true
  })) ?? binName;
}
async function getAgentVersion(agentExecPath, cwd) {
  let result;
  try {
    result = semver.coerce(
    // All package managers support the "--version" flag.
    (await spawn(agentExecPath, ['--version'], {
      cwd
    })).stdout) ?? undefined;
  } catch {}
  return result;
}

// The order of LOCKS properties IS significant as it affects iteration order.
const LOCKS = {
  [`bun${LOCK_EXT$1}`]: BUN$5,
  [`bun${BINARY_LOCK_EXT}`]: BUN$5,
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  'npm-shrinkwrap.json': NPM$8,
  'package-lock.json': NPM$8,
  'pnpm-lock.yaml': PNPM$6,
  'pnpm-lock.yml': PNPM$6,
  [`yarn${LOCK_EXT$1}`]: YARN_CLASSIC$5,
  'vlt-lock.json': VLT$5,
  // Lastly, look for a hidden lock file which is present if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  'node_modules/.package-lock.json': NPM$8
};
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (...args) => {
      try {
        return await reader(...args);
      } catch {}
      return undefined;
    };
  }
  const binaryReader = wrapReader(index.readFileBinary);
  const defaultReader = wrapReader(async lockPath => await index.readFileUtf8(lockPath));
  return {
    [BUN$5]: wrapReader(async (lockPath, agentExecPath) => {
      const ext = path.extname(lockPath);
      if (ext === LOCK_EXT$1) {
        return await defaultReader(lockPath);
      }
      if (ext === BINARY_LOCK_EXT) {
        const lockBuffer = await binaryReader(lockPath);
        if (lockBuffer) {
          try {
            return index_cjs.parse(lockBuffer);
          } catch {}
        }
        // To print a Yarn lockfile to your console without writing it to disk
        // use `bun bun.lockb`.
        // https://bun.sh/guides/install/yarnlock
        return (await spawn(agentExecPath, [lockPath])).stdout.trim();
      }
      return undefined;
    }),
    [NPM$8]: defaultReader,
    [PNPM$6]: defaultReader,
    [VLT$5]: defaultReader,
    [YARN_BERRY$5]: defaultReader,
    [YARN_CLASSIC$5]: defaultReader
  };
})();
async function detect({
  cwd = process$1.cwd(),
  onUnknown
} = {}) {
  let lockPath = await index.findUp(Object.keys(LOCKS), {
    cwd
  });
  let lockBasename = lockPath ? path.basename(lockPath) : undefined;
  const isHiddenLockFile = lockBasename === '.package-lock.json';
  const pkgJsonPath = lockPath ? path.resolve(lockPath, `${isHiddenLockFile ? '../' : ''}../package.json`) : await index.findUp('package.json', {
    cwd
  });
  const pkgPath = pkgJsonPath && fs.existsSync(pkgJsonPath) ? path.dirname(pkgJsonPath) : undefined;
  const editablePkgJson = pkgPath ? await packages.readPackageJson(pkgPath, {
    editable: true
  }) : undefined;
  const pkgJson = editablePkgJson?.content;
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = strings.isNonEmptyString(pkgJson?.packageManager) ? pkgJson.packageManager : undefined;
  let agent;
  let agentVersion;
  if (pkgManager) {
    const atSignIndex = pkgManager.lastIndexOf('@');
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex);
      const version = pkgManager.slice(atSignIndex + 1);
      if (version && AGENTS.includes(name)) {
        agent = name;
        agentVersion = semver.coerce(version) ?? undefined;
      }
    }
  }
  if (agent === undefined && !isHiddenLockFile && typeof pkgJsonPath === 'string' && typeof lockBasename === 'string') {
    agent = LOCKS[lockBasename];
  }
  if (agent === undefined) {
    agent = NPM$8;
    onUnknown?.(pkgManager);
  }
  const agentExecPath = await getAgentExecPath(agent);
  const npmExecPath = agent === NPM$8 ? agentExecPath : await getAgentExecPath(NPM$8);
  if (agentVersion === undefined) {
    agentVersion = await getAgentVersion(agentExecPath, cwd);
  }
  if (agent === YARN_CLASSIC$5 && (agentVersion?.major ?? 0) > 1) {
    agent = YARN_BERRY$5;
  }
  const targets = {
    browser: false,
    node: true
  };
  let lockSrc;
  // Lazily access constants.maintainedNodeVersions.
  let minimumNodeVersion = constants.maintainedNodeVersions.previous;
  if (pkgJson) {
    const browserField = pkgJson.browser;
    if (strings.isNonEmptyString(browserField) || objects.isObjectObject(browserField)) {
      targets.browser = true;
    }
    const nodeRange = pkgJson.engines?.['node'];
    if (strings.isNonEmptyString(nodeRange)) {
      const coerced = semver.coerce(nodeRange);
      if (coerced && semver.lt(coerced, minimumNodeVersion)) {
        minimumNodeVersion = coerced.version;
      }
    }
    const browserslistQuery = pkgJson['browserslist'];
    if (Array.isArray(browserslistQuery)) {
      const browserslistTargets = browserslist(browserslistQuery).map(s => s.toLowerCase()).sort(sorts.naturalCompare);
      const browserslistNodeTargets = browserslistTargets.filter(v => v.startsWith('node ')).map(v => v.slice(5 /*'node '.length*/));
      if (!targets.browser && browserslistTargets.length) {
        targets.browser = browserslistTargets.length !== browserslistNodeTargets.length;
      }
      if (browserslistNodeTargets.length) {
        const coerced = semver.coerce(browserslistNodeTargets[0]);
        if (coerced && semver.lt(coerced, minimumNodeVersion)) {
          minimumNodeVersion = coerced.version;
        }
      }
    }
    // Lazily access constants.maintainedNodeVersions.
    targets.node = constants.maintainedNodeVersions.some(v => semver.satisfies(v, `>=${minimumNodeVersion}`));
    lockSrc = typeof lockPath === 'string' ? await readLockFileByAgent[agent](lockPath, agentExecPath) : undefined;
  } else {
    lockBasename = undefined;
    lockPath = undefined;
  }
  return {
    agent,
    agentExecPath,
    agentVersion,
    lockBasename,
    lockPath,
    lockSrc,
    minimumNodeVersion,
    npmExecPath,
    pkgJson: editablePkgJson,
    pkgPath,
    supported: targets.browser || targets.node,
    targets
  };
}

const {
  BUN: BUN$4,
  NPM: NPM$7,
  VLT: VLT$4,
  YARN_BERRY: YARN_BERRY$4
} = constants;
const COMMAND_TITLE$2 = 'Socket Optimize';
const manifestNpmOverrides = registry.getManifestData(NPM$7);
async function detectAndValidatePackageManager(cwd, prod) {
  const {
    agent,
    agentExecPath,
    agentVersion,
    lockBasename,
    lockPath,
    lockSrc,
    minimumNodeVersion,
    npmExecPath,
    pkgJson,
    pkgPath,
    supported
  } = await detect({
    cwd,
    onUnknown(pkgManager) {
      console.warn(` ${COMMAND_TITLE$2}: Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`);
    }
  });
  if (!supported) {
    console.error(` ${COMMAND_TITLE$2}: No supported Node or browser range detected`);
    return;
  }
  if (agent === VLT$4) {
    console.error(` ${COMMAND_TITLE$2}: ${agent} does not support overrides. Soon, though `);
    return;
  }
  const lockName = lockPath && lockBasename ? lockBasename : 'lock file';
  if (lockBasename === undefined || lockSrc === undefined) {
    console.error(` ${COMMAND_TITLE$2}: No ${lockName} found`);
    return;
  }
  if (lockSrc.trim() === '') {
    console.error(` ${COMMAND_TITLE$2}: ${lockName} is empty`);
    return;
  }
  if (pkgPath === undefined) {
    console.error(` ${COMMAND_TITLE$2}: No package.json found`);
    return;
  }
  if (prod && (agent === BUN$4 || agent === YARN_BERRY$4)) {
    console.error(` ${COMMAND_TITLE$2}: --prod not supported for ${agent}${agentVersion ? `@${agentVersion.toString()}` : ''}`);
    return;
  }
  if (lockPath && path.relative(cwd, lockPath).startsWith('.')) {
    console.warn(` ${COMMAND_TITLE$2}: Package ${lockName} found at ${lockPath}`);
  }
  const nodeRange = `>=${minimumNodeVersion}`;
  const manifestEntries = manifestNpmOverrides.filter(({
    1: data
  }) => semver.satisfies(semver.coerce(data.engines.node), nodeRange));
  return {
    agent,
    agentExecPath,
    lockBasename,
    lockName,
    lockSrc,
    manifestEntries,
    npmExecPath,
    pkgJson,
    pkgPath
  };
}

function getDependencyEntries(pkgJson) {
  const {
    dependencies,
    devDependencies,
    optionalDependencies,
    peerDependencies
  } = pkgJson;
  return [['dependencies', dependencies ? {
    __proto__: null,
    ...dependencies
  } : undefined], ['devDependencies', devDependencies ? {
    __proto__: null,
    ...devDependencies
  } : undefined], ['peerDependencies', peerDependencies ? {
    __proto__: null,
    ...peerDependencies
  } : undefined], ['optionalDependencies', optionalDependencies ? {
    __proto__: null,
    ...optionalDependencies
  } : undefined]].filter(({
    1: o
  }) => o);
}

const {
  BUN: BUN$3,
  NPM: NPM$6,
  OVERRIDES: OVERRIDES$1,
  PNPM: PNPM$5,
  RESOLUTIONS: RESOLUTIONS$1,
  VLT: VLT$3,
  YARN_BERRY: YARN_BERRY$3,
  YARN_CLASSIC: YARN_CLASSIC$4
} = constants;
function getOverridesDataBun(pkgJson) {
  const overrides = pkgJson?.[RESOLUTIONS$1] ?? {};
  return {
    type: YARN_BERRY$3,
    overrides
  };
}

// npm overrides documentation:
// https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides
function getOverridesDataNpm(pkgJson) {
  const overrides = pkgJson?.[OVERRIDES$1] ?? {};
  return {
    type: NPM$6,
    overrides
  };
}

// pnpm overrides documentation:
// https://pnpm.io/package_json#pnpmoverrides
function getOverridesDataPnpm(pkgJson) {
  const overrides = pkgJson?.pnpm?.[OVERRIDES$1] ?? {};
  return {
    type: PNPM$5,
    overrides
  };
}
function getOverridesDataVlt(pkgJson) {
  const overrides = pkgJson?.[OVERRIDES$1] ?? {};
  return {
    type: VLT$3,
    overrides
  };
}

// Yarn resolutions documentation:
// https://yarnpkg.com/configuration/manifest#resolutions
function getOverridesDataYarn(pkgJson) {
  const overrides = pkgJson?.[RESOLUTIONS$1] ?? {};
  return {
    type: YARN_BERRY$3,
    overrides
  };
}

// Yarn resolutions documentation:
// https://classic.yarnpkg.com/en/docs/selective-version-resolutions
function getOverridesDataClassic(pkgJson) {
  const overrides = pkgJson?.[RESOLUTIONS$1] ?? {};
  return {
    type: YARN_CLASSIC$4,
    overrides
  };
}
const getOverridesDataByAgent = {
  // @ts-ignore
  __proto__: null,
  [BUN$3]: getOverridesDataBun,
  [NPM$6]: getOverridesDataNpm,
  [PNPM$5]: getOverridesDataPnpm,
  [VLT$3]: getOverridesDataVlt,
  [YARN_BERRY$3]: getOverridesDataYarn,
  [YARN_CLASSIC$4]: getOverridesDataClassic
};

const {
  PNPM: PNPM$4
} = constants;
const PNPM_WORKSPACE = `${PNPM$4}-workspace`;
async function getWorkspaceGlobs(agent, pkgPath, pkgJson) {
  let workspacePatterns;
  if (agent === PNPM$4) {
    for (const workspacePath of [path.join(pkgPath, `${PNPM_WORKSPACE}.yaml`), path.join(pkgPath, `${PNPM_WORKSPACE}.yml`)]) {
      // eslint-disable-next-line no-await-in-loop
      const yml = await index.safeReadFile(workspacePath, 'utf8');
      if (yml) {
        try {
          workspacePatterns = yaml.parse(yml)?.packages;
        } catch {}
        if (workspacePatterns) {
          break;
        }
      }
    }
  } else {
    workspacePatterns = pkgJson['workspaces'];
  }
  return Array.isArray(workspacePatterns) ? workspacePatterns.filter(strings.isNonEmptyString).map(workspacePatternToGlobPattern) : undefined;
}
function workspacePatternToGlobPattern(workspace) {
  const {
    length
  } = workspace;
  if (!length) {
    return '';
  }
  // If the workspace ends with "/"
  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {
    return `${workspace}/*/package.json`;
  }
  // If the workspace ends with "/**"
  if (workspace.charCodeAt(length - 1) === 42 /*'*'*/ && workspace.charCodeAt(length - 2) === 42 /*'*'*/ && workspace.charCodeAt(length - 3) === 47 /*'/'*/) {
    return `${workspace}/*/**/package.json`;
  }
  // Things like "packages/a" or "packages/*"
  return `${workspace}/package.json`;
}

const {
  BUN: BUN$2,
  LOCK_EXT,
  NPM: NPM$5,
  PNPM: PNPM$3,
  VLT: VLT$2,
  YARN_BERRY: YARN_BERRY$2,
  YARN_CLASSIC: YARN_CLASSIC$3
} = constants;
function lockIncludesNpm(lockSrc, name) {
  // Detects the package name in the following cases:
  //   "name":
  return lockSrc.includes(`"${name}":`);
}
function lockIncludesBun(lockSrc, name, lockBasename) {
  // This is a bit counterintuitive. When lockBasename ends with a .lockb
  // we treat it as a yarn.lock. When lockBasename ends with a .lock we
  // treat it as a package-lock.json. The bun.lock format is not identical
  // package-lock.json, however it close enough for npmLockIncludes to work.
  const lockScanner = lockBasename?.endsWith(LOCK_EXT) ? lockIncludesNpm : lockIncludesYarn;
  return lockScanner(lockSrc, name);
}
function lockIncludesPnpm(lockSrc, name) {
  const escapedName = regexps.escapeRegExp(name);
  return new RegExp(
  // Detects the package name in the following cases:
  //   /name/
  //   'name'
  //   name:
  //   name@
  `(?<=^\\s*)(?:(['/])${escapedName}\\1|${escapedName}(?=[:@]))`, 'm').test(lockSrc);
}
function lockIncludesVlt(lockSrc, name) {
  // Detects the package name in the following cases:
  //   "name"
  return lockSrc.includes(`"${name}"`);
}
function lockIncludesYarn(lockSrc, name) {
  const escapedName = regexps.escapeRegExp(name);
  return new RegExp(
  // Detects the package name in the following cases:
  //   "name@
  //   , "name@
  //   name@
  //   , name@
  `(?<=(?:^\\s*|,\\s*)"?)${escapedName}(?=@)`, 'm').test(lockSrc);
}
const lockIncludesByAgent = {
  // @ts-ignore
  __proto__: null,
  [BUN$2]: lockIncludesBun,
  [NPM$5]: lockIncludesNpm,
  [PNPM$3]: lockIncludesPnpm,
  [VLT$2]: lockIncludesVlt,
  [YARN_BERRY$2]: lockIncludesYarn,
  [YARN_CLASSIC$3]: lockIncludesYarn
};

const {
  BUN: BUN$1,
  NPM: NPM$4,
  PNPM: PNPM$2,
  VLT: VLT$1,
  YARN_BERRY: YARN_BERRY$1,
  YARN_CLASSIC: YARN_CLASSIC$2
} = constants;
function cleanupQueryStdout(stdout) {
  if (stdout === '') {
    return '';
  }
  let pkgs;
  try {
    pkgs = JSON.parse(stdout);
  } catch {}
  if (!Array.isArray(pkgs)) {
    return '';
  }
  const names = new Set();
  for (const {
    _id,
    name,
    pkgid
  } of pkgs) {
    // `npm query` results may not have a "name" property, in which case we
    // fallback to "_id" and then "pkgid".
    // `vlt ls --view json` results always have a "name" property.
    const fallback = _id ?? pkgid ?? '';
    const resolvedName = name ?? fallback.slice(0, fallback.indexOf('@', 1));
    // Add package names, except for those under the `@types` scope as those
    // are known to only be dev dependencies.
    if (resolvedName && !resolvedName.startsWith('@types/')) {
      names.add(resolvedName);
    }
  }
  return JSON.stringify([...names], null, 2);
}
function parseableToQueryStdout(stdout) {
  if (stdout === '') {
    return '';
  }
  // Convert the parseable stdout into a json array of unique names.
  // The matchAll regexp looks for a forward (posix) or backward (win32) slash
  // and matches one or more non-slashes until the newline.
  const names = new Set(stdout.matchAll(/(?<=[/\\])[^/\\]+(?=\n)/g));
  return JSON.stringify([...names], null, 2);
}
async function npmQuery(npmExecPath, cwd) {
  let stdout = '';
  try {
    stdout = (await spawn(npmExecPath, ['query', ':not(.dev)'], {
      cwd
    })).stdout;
  } catch {}
  return cleanupQueryStdout(stdout);
}
async function lsBun(agentExecPath, cwd) {
  try {
    // Bun does not support filtering by production packages yet.
    // https://github.com/oven-sh/bun/issues/8283
    return (await spawn(agentExecPath, ['pm', 'ls', '--all'], {
      cwd
    })).stdout;
  } catch {}
  return '';
}
async function lsNpm(agentExecPath, cwd) {
  return await npmQuery(agentExecPath, cwd);
}
async function lsPnpm(agentExecPath, cwd, options) {
  const npmExecPath = options?.npmExecPath;
  if (npmExecPath && npmExecPath !== NPM$4) {
    const result = await npmQuery(npmExecPath, cwd);
    if (result) {
      return result;
    }
  }
  let stdout = '';
  try {
    stdout = (await spawn(agentExecPath, ['ls', '--parseable', '--prod', '--depth', 'Infinity'], {
      cwd
    })).stdout;
  } catch {}
  return parseableToQueryStdout(stdout);
}
async function lsVlt(agentExecPath, cwd) {
  let stdout = '';
  try {
    stdout = (await spawn(agentExecPath, ['ls', '--view', 'human', ':not(.dev)'], {
      cwd
    })).stdout;
  } catch {}
  return cleanupQueryStdout(stdout);
}
async function lsYarnBerry(agentExecPath, cwd) {
  try {
    return (
      // Yarn Berry does not support filtering by production packages yet.
      // https://github.com/yarnpkg/berry/issues/5117
      (await spawn(agentExecPath, ['info', '--recursive', '--name-only'], {
        cwd
      })).stdout.trim()
    );
  } catch {}
  return '';
}
async function lsYarnClassic(agentExecPath, cwd) {
  try {
    // However, Yarn Classic does support it.
    // https://github.com/yarnpkg/yarn/releases/tag/v1.0.0
    // > Fix: Excludes dev dependencies from the yarn list output when the
    //   environment is production
    return (await spawn(agentExecPath, ['list', '--prod'], {
      cwd
    })).stdout.trim();
  } catch {}
  return '';
}
const lsByAgent = {
  // @ts-ignore
  __proto__: null,
  [BUN$1]: lsBun,
  [NPM$4]: lsNpm,
  [PNPM$2]: lsPnpm,
  [VLT$1]: lsVlt,
  [YARN_BERRY$1]: lsYarnBerry,
  [YARN_CLASSIC$2]: lsYarnClassic
};

const {
  BUN,
  NPM: NPM$3,
  OVERRIDES,
  PNPM: PNPM$1,
  RESOLUTIONS,
  VLT,
  YARN_BERRY,
  YARN_CLASSIC: YARN_CLASSIC$1
} = constants;
const PNPM_FIELD_NAME = PNPM$1;
const depFields = ['dependencies', 'devDependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies'];
function getEntryIndexes(entries, keys) {
  return keys.map(n => entries.findIndex(p => p[0] === n)).filter(n => n !== -1).sort((a, b) => a - b);
}
function getLowestEntryIndex(entries, keys) {
  return getEntryIndexes(entries, keys)?.[0] ?? -1;
}
function getHighestEntryIndex(entries, keys) {
  return getEntryIndexes(entries, keys).at(-1) ?? -1;
}
function updatePkgJson(editablePkgJson, field, value) {
  const pkgJson = editablePkgJson.content;
  const oldValue = pkgJson[field];
  if (oldValue) {
    // The field already exists so we simply update the field value.
    if (field === PNPM_FIELD_NAME) {
      if (objects.hasKeys(value)) {
        editablePkgJson.update({
          [field]: {
            ...(objects.isObject(oldValue) ? oldValue : {}),
            overrides: value
          }
        });
      } else {
        // Properties with undefined values are omitted when saved as JSON.
        editablePkgJson.update(objects.hasKeys(pkgJson[field]) ? {
          [field]: {
            ...(objects.isObject(oldValue) ? oldValue : {}),
            overrides: undefined
          }
        } : {
          [field]: undefined
        });
      }
    } else if (field === OVERRIDES || field === RESOLUTIONS) {
      // Properties with undefined values are omitted when saved as JSON.
      editablePkgJson.update({
        [field]: objects.hasKeys(value) ? value : undefined
      });
    } else {
      editablePkgJson.update({
        [field]: value
      });
    }
    return;
  }
  if ((field === OVERRIDES || field === PNPM_FIELD_NAME || field === RESOLUTIONS) && !objects.hasKeys(value)) {
    return;
  }
  // Since the field doesn't exist we want to insert it into the package.json
  // in a place that makes sense, e.g. close to the "dependencies" field. If
  // we can't find a place to insert the field we'll add it to the bottom.
  const entries = Object.entries(pkgJson);
  let insertIndex = -1;
  let isPlacingHigher = false;
  if (field === OVERRIDES) {
    insertIndex = getLowestEntryIndex(entries, [RESOLUTIONS]);
    if (insertIndex === -1) {
      isPlacingHigher = true;
      insertIndex = getHighestEntryIndex(entries, [...depFields, PNPM$1]);
    }
  } else if (field === RESOLUTIONS) {
    isPlacingHigher = true;
    insertIndex = getHighestEntryIndex(entries, [...depFields, OVERRIDES, PNPM$1]);
  } else if (field === PNPM_FIELD_NAME) {
    insertIndex = getLowestEntryIndex(entries, [OVERRIDES, RESOLUTIONS]);
    if (insertIndex === -1) {
      isPlacingHigher = true;
      insertIndex = getHighestEntryIndex(entries, depFields);
    }
  }
  if (insertIndex === -1) {
    insertIndex = getLowestEntryIndex(entries, ['engines', 'files']);
  }
  if (insertIndex === -1) {
    isPlacingHigher = true;
    insertIndex = getHighestEntryIndex(entries, ['exports', 'imports', 'main']);
  }
  if (insertIndex === -1) {
    insertIndex = entries.length;
  } else if (isPlacingHigher) {
    insertIndex += 1;
  }
  entries.splice(insertIndex, 0, [field, value]);
  editablePkgJson.fromJSON(`${JSON.stringify(Object.fromEntries(entries), null, 2)}\n`);
}
function updateOverrides(editablePkgJson, overrides) {
  updatePkgJson(editablePkgJson, OVERRIDES, overrides);
}
function updateResolutions(editablePkgJson, overrides) {
  updatePkgJson(editablePkgJson, RESOLUTIONS, overrides);
}
function pnpmUpdatePkgJson(editablePkgJson, overrides) {
  updatePkgJson(editablePkgJson, PNPM_FIELD_NAME, overrides);
}
const updateManifestByAgent = {
  // @ts-ignore
  __proto__: null,
  [BUN]: updateResolutions,
  [NPM$3]: updateOverrides,
  [PNPM$1]: pnpmUpdatePkgJson,
  [VLT]: updateOverrides,
  [YARN_BERRY]: updateResolutions,
  [YARN_CLASSIC$1]: updateResolutions
};

const {
  NPM: NPM$2,
  SOCKET_CLI_SAFE_WRAPPER,
  abortSignal: abortSignal$2
} = constants;
const COMMAND_TITLE$1 = 'Socket Optimize';
const NPM_OVERRIDE_PR_URL = 'https://github.com/npm/cli/pull/7025';
async function updatePackageLockJson(lockName, agentExecPath, agent, spinner) {
  spinner.start(`Updating ${lockName}...`);
  try {
    if (agent === NPM$2) {
      const ipc = {
        [SOCKET_CLI_SAFE_WRAPPER]: true
      };
      await npm$1.safeNpmInstall({
        ipc
      });
      // TODO: This is a temporary workaround for a `npm ci` bug where it
      //       will error out after Socket Optimize generates a lock file.
      //       More investigation is needed.
      await npm$1.safeNpmInstall({
        args: ['--ignore-scripts', '--package-lock-only'],
        ipc
      });
    } else {
      // All package managers support the "install" command.
      await spawn(agentExecPath, ['install'], {
        signal: abortSignal$2,
        stdio: 'ignore'
      });
    }
    spinner.stop();
    if (agent === NPM$2) {
      console.log(` Re-run ${COMMAND_TITLE$1} whenever ${lockName} changes.\n   This can be skipped once npm ships ${NPM_OVERRIDE_PR_URL}.`);
    }
  } catch (e) {
    spinner.error(`${COMMAND_TITLE$1}: ${agent} install failed to update ${lockName}`);
    console.error(e);
  }
}

const {
  NPM: NPM$1,
  PNPM,
  YARN_CLASSIC
} = constants;
const COMMAND_TITLE = 'Socket Optimize';
async function applyOptimization(cwd, pin, prod) {
  const pkgMgrData = await detectAndValidatePackageManager(cwd, prod);
  if (!pkgMgrData) return;
  const {
    agent,
    agentExecPath,
    lockBasename,
    lockName,
    lockSrc,
    manifestEntries,
    npmExecPath,
    pkgJson,
    pkgPath
  } = pkgMgrData;
  const spinner$1 = new spinner.Spinner({
    text: 'Socket optimizing...'
  });
  spinner$1.start();
  const state = await addOverrides({
    agent,
    agentExecPath,
    lockBasename,
    lockSrc,
    manifestEntries,
    npmExecPath,
    pin,
    pkgJson,
    pkgPath,
    prod,
    rootPath: pkgPath
  }, createAddOverridesState(spinner$1));
  spinner$1.stop();
  const addedCount = state.added.size;
  const updatedCount = state.updated.size;
  const pkgJsonChanged = addedCount > 0 || updatedCount > 0;
  if (pkgJsonChanged) {
    if (updatedCount > 0) {
      console.log(`${createActionMessage('Updated', updatedCount, state.updatedInWorkspaces.size)}${addedCount ? '.' : ''}`);
    }
    if (addedCount > 0) {
      console.log(`${createActionMessage('Added', addedCount, state.addedInWorkspaces.size)} `);
    }
  } else {
    console.log('Congratulations! Already Socket.dev optimized ');
  }
  if (agent === NPM$1 || pkgJsonChanged) {
    // Always update package-lock.json until the npm overrides PR lands:
    // https://github.com/npm/cli/pull/7025
    await updatePackageLockJson(lockName, agentExecPath, agent, spinner$1);
  }
}
function createActionMessage(verb, overrideCount, workspaceCount) {
  return `${verb} ${overrideCount} Socket.dev optimized ${words.pluralize('override', overrideCount)}${workspaceCount ? ` in ${workspaceCount} ${words.pluralize('workspace', workspaceCount)}` : ''}`;
}
function createAddOverridesState(spinner) {
  return {
    added: new Set(),
    addedInWorkspaces: new Set(),
    spinner,
    updated: new Set(),
    updatedInWorkspaces: new Set(),
    warnedPnpmWorkspaceRequiresNpm: false
  };
}
async function addOverrides({
  agent,
  agentExecPath,
  lockBasename,
  lockSrc,
  manifestEntries,
  npmExecPath,
  pin,
  pkgJson: editablePkgJson,
  pkgPath,
  prod,
  rootPath
}, state) {
  if (editablePkgJson === undefined) {
    editablePkgJson = await packages.readPackageJson(pkgPath, {
      editable: true
    });
  }
  const {
    spinner
  } = state;
  const {
    content: pkgJson
  } = editablePkgJson;
  const isRoot = pkgPath === rootPath;
  const isLockScanned = isRoot && !prod;
  const workspaceName = path.relative(rootPath, pkgPath);
  const workspaceGlobs = await getWorkspaceGlobs(agent, pkgPath, pkgJson);
  const isWorkspace = !!workspaceGlobs;
  if (isWorkspace && agent === PNPM && npmExecPath === NPM$1 && !state.warnedPnpmWorkspaceRequiresNpm) {
    state.warnedPnpmWorkspaceRequiresNpm = true;
    console.warn(` ${COMMAND_TITLE}: pnpm workspace support requires \`npm ls\`, falling back to \`pnpm list\``);
  }
  const thingToScan = isLockScanned ? lockSrc : await lsByAgent[agent](agentExecPath, pkgPath, {
    npmExecPath
  });
  // The AgentDepsIncludesFn and AgentLockIncludesFn types overlap in their
  // first two parameters. AgentLockIncludesFn accepts an optional third
  // parameter which AgentDepsIncludesFn will ignore so we cast thingScanner
  // as an AgentLockIncludesFn type.
  const thingScanner = isLockScanned ? lockIncludesByAgent[agent] : depsIncludesByAgent[agent];
  const depEntries = getDependencyEntries(pkgJson);
  const overridesDataObjects = [];
  if (pkgJson['private'] || isWorkspace) {
    overridesDataObjects.push(getOverridesDataByAgent[agent](pkgJson));
  } else {
    overridesDataObjects.push(getOverridesDataByAgent[NPM$1](pkgJson), getOverridesDataByAgent[YARN_CLASSIC](pkgJson));
  }
  if (spinner) {
    spinner.text = `Adding overrides${workspaceName ? ` to ${workspaceName}` : ''}...`;
  }
  const depAliasMap = new Map();
  // Chunk package names to process them in parallel 3 at a time.
  await promises.pEach(manifestEntries, 3, async ({
    1: data
  }) => {
    const {
      name: sockRegPkgName,
      package: origPkgName,
      version
    } = data;
    const major = semver.major(version);
    const sockOverridePrefix = `${NPM$1}:${sockRegPkgName}@`;
    const sockOverrideSpec = `${sockOverridePrefix}${pin ? version : `^${major}`}`;
    for (const {
      1: depObj
    } of depEntries) {
      const sockSpec = objects.hasOwn(depObj, sockRegPkgName) ? depObj[sockRegPkgName] : undefined;
      if (sockSpec) {
        depAliasMap.set(sockRegPkgName, sockSpec);
      }
      const origSpec = objects.hasOwn(depObj, origPkgName) ? depObj[origPkgName] : undefined;
      if (origSpec) {
        let thisSpec = origSpec;
        // Add package aliases for direct dependencies to avoid npm EOVERRIDE errors.
        // https://docs.npmjs.com/cli/v8/using-npm/package-spec#aliases
        if (!(thisSpec.startsWith(sockOverridePrefix) && semver.coerce(npa(thisSpec).rawSpec)?.version)) {
          thisSpec = sockOverrideSpec;
          depObj[origPkgName] = thisSpec;
          state.added.add(sockRegPkgName);
          if (workspaceName) {
            state.addedInWorkspaces.add(workspaceName);
          }
        }
        depAliasMap.set(origPkgName, thisSpec);
      }
    }
    if (isRoot) {
      // Chunk package names to process them in parallel 3 at a time.
      await promises.pEach(overridesDataObjects, 3, async ({
        overrides,
        type
      }) => {
        const overrideExists = objects.hasOwn(overrides, origPkgName);
        if (overrideExists || thingScanner(thingToScan, origPkgName, lockBasename)) {
          const oldSpec = overrideExists ? overrides[origPkgName] : undefined;
          const origDepAlias = depAliasMap.get(origPkgName);
          const sockRegDepAlias = depAliasMap.get(sockRegPkgName);
          const depAlias = sockRegDepAlias ?? origDepAlias;
          let newSpec = sockOverrideSpec;
          if (type === NPM$1 && depAlias) {
            // With npm one may not set an override for a package that one directly
            // depends on unless both the dependency and the override itself share
            // the exact same spec. To make this limitation easier to deal with,
            // overrides may also be defined as a reference to a spec for a direct
            // dependency by prefixing the name of the package to match the version
            // of with a $.
            // https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides
            newSpec = `$${sockRegDepAlias ? sockRegPkgName : origPkgName}`;
          } else if (typeof oldSpec === 'string') {
            const thisSpec = oldSpec.startsWith('$') ? depAlias || newSpec : oldSpec || newSpec;
            if (thisSpec.startsWith(sockOverridePrefix)) {
              if (pin && semver.major(semver.coerce(npa(thisSpec).rawSpec)?.version ?? version) !== major) {
                const otherVersion = (await packages.fetchPackageManifest(thisSpec))?.version;
                if (otherVersion && otherVersion !== version) {
                  newSpec = `${sockOverridePrefix}${pin ? otherVersion : `^${semver.major(otherVersion)}`}`;
                }
              }
            } else {
              newSpec = oldSpec;
            }
          }
          if (newSpec !== oldSpec) {
            overrides[origPkgName] = newSpec;
            const addedOrUpdated = overrideExists ? 'updated' : 'added';
            state[addedOrUpdated].add(sockRegPkgName);
          }
        }
      });
    }
  });
  if (workspaceGlobs) {
    const workspacePkgJsonPaths = await tinyglobby.glob(workspaceGlobs, {
      absolute: true,
      cwd: pkgPath,
      ignore: ['**/node_modules/**', '**/bower_components/**']
    });
    // Chunk package names to process them in parallel 3 at a time.
    await promises.pEach(workspacePkgJsonPaths, 3, async workspacePkgJsonPath => {
      const otherState = await addOverrides({
        agent,
        agentExecPath,
        lockBasename,
        lockSrc,
        manifestEntries,
        npmExecPath,
        pin,
        pkgPath: path.dirname(workspacePkgJsonPath),
        prod,
        rootPath
      }, createAddOverridesState(spinner));
      for (const key of ['added', 'addedInWorkspaces', 'updated', 'updatedInWorkspaces']) {
        for (const value of otherState[key]) {
          state[key].add(value);
        }
      }
    });
  }
  if (state.added.size > 0 || state.updated.size > 0) {
    editablePkgJson.update(Object.fromEntries(depEntries));
    for (const {
      overrides,
      type
    } of overridesDataObjects) {
      updateManifestByAgent[type](editablePkgJson, objects.toSortedObject(overrides));
    }
    await editablePkgJson.save();
  }
  return state;
}

const config$h = {
  commandName: 'create',
  description: 'Optimize dependencies with @socketregistry overrides',
  hidden: false,
  flags: {
    ...commonFlags,
    pin: {
      type: 'boolean',
      default: false,
      description: 'Pin overrides to their latest version'
    },
    prod: {
      type: 'boolean',
      default: false,
      description: 'Only add overrides for production dependencies'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}
      $ ${command} --pin
  `
};
const cmdOptimize = {
  description: config$h.description,
  hidden: config$h.hidden,
  run: run$h
};
async function run$h(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$h,
    importMeta,
    parentName
  });
  const cwd = process$1.cwd();
  await applyOptimization(cwd, Boolean(cli.flags['pin']), Boolean(cli.flags['prod']));
}

async function getOrganizations() {
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  const spinner$1 = new spinner.Spinner({
    text: 'Fetching organizations...'
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getOrganizations(), 'looking up organizations');
  if (result.success === false) {
    handleUnsuccessfulApiResponse('getOrganizations', result, spinner$1);
    return;
  }
  spinner$1.stop(`List of organizations associated with your API key: ${colors.italic(apiToken)}`);
  const organizations = Object.values(result.data.organizations);
  for (const o of organizations) {
    console.log(`
Name: ${o?.name}
ID: ${o?.id}
Plan: ${o?.plan}
    `);
  }
}

const config$g = {
  commandName: 'organizations',
  description: 'List organizations associated with the API key used',
  hidden: false,
  flags: {},
  help: (command, _config) => `
    Usage
      $ ${command}
  `
};
const cmdOrganizations = {
  description: config$g.description,
  hidden: config$g.hidden,
  run: run$g
};
async function run$g(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    argv,
    config: config$g,
    importMeta,
    parentName
  });
  await getOrganizations();
}

const {
  abortSignal: abortSignal$1
} = constants;
async function runRawNpm(argv) {
  const spawnPromise = spawn(npmPaths.getNpmBinPath(), argv.slice(0), {
    signal: abortSignal$1,
    stdio: 'inherit'
  });
  // See https://nodejs.org/api/all.html#all_child_process_event-exit.
  spawnPromise.process.on('exit', (code, signalName) => {
    if (abortSignal$1.aborted) {
      return;
    }
    if (signalName) {
      process$1.kill(process$1.pid, signalName);
    } else if (code !== null) {
      process$1.exit(code);
    }
  });
  await spawnPromise;
}

const {
  NPM
} = constants;
const config$f = {
  commandName: 'raw-npm',
  description: `Temporarily disable the Socket ${NPM} wrapper`,
  hidden: false,
  flags: {},
  help: (command, config) => `
    Usage
      $ ${command} <command>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} install
  `
};
const cmdRawNpm = {
  description: config$f.description,
  hidden: config$f.hidden,
  run: run$f
};
async function run$f(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$f,
    importMeta,
    parentName
  });
  await runRawNpm(argv);
}

const {
  abortSignal
} = constants;
async function runRawNpx(argv) {
  const spawnPromise = spawn(npmPaths.getNpxBinPath(), argv, {
    signal: abortSignal,
    stdio: 'inherit'
  });
  // See https://nodejs.org/api/all.html#all_child_process_event-exit.
  spawnPromise.process.on('exit', (code, signalName) => {
    if (abortSignal.aborted) {
      return;
    }
    if (signalName) {
      process$1.kill(process$1.pid, signalName);
    } else if (code !== null) {
      process$1.exit(code);
    }
  });
  await spawnPromise;
}

const {
  NPX
} = constants;
const config$e = {
  commandName: 'raw-npx',
  description: `Temporarily disable the Socket ${NPX} wrapper`,
  hidden: false,
  flags: {},
  help: (command, config) => `
    Usage
      $ ${command} <command>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} install
  `
};
const cmdRawNpx = {
  description: config$e.description,
  hidden: config$e.hidden,
  run: run$e
};
async function run$e(argv, importMeta, {
  parentName
}) {
  meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$e,
    importMeta,
    parentName
  });
  await runRawNpx(argv);
}

async function createReport(socketConfig, inputPaths, {
  cwd,
  dryRun
}) {
  const socketSdk = await index.setupSdk();
  const supportedFiles = await socketSdk.getReportSupportedFiles().then(res => {
    if (!res.success) handleUnsuccessfulApiResponse('getReportSupportedFiles', res, new spinner.Spinner());
    return res.data;
  }).catch(cause => {
    throw new Error('Failed getting supported files for report', {
      cause
    });
  });
  const packagePaths = await npmPaths.getPackageFiles(cwd, inputPaths, socketConfig, supportedFiles);
  npmPaths.debugLog('Uploading:', packagePaths.join(`\n${npmPaths.getLogSymbols().info} Uploading: `));
  if (dryRun) {
    npmPaths.debugLog('[dryRun] Skipped actual upload');
    return undefined;
  } else {
    const socketSdk = await index.setupSdk();
    const spinner$1 = new spinner.Spinner({
      text: `Creating report with ${packagePaths.length} package files`
    }).start();
    const apiCall = socketSdk.createReportFromFilePaths(packagePaths, cwd, socketConfig?.issueRules);
    const result = await handleApiCall(apiCall, 'creating report');
    if (!result.success) {
      handleUnsuccessfulApiResponse('createReport', result, spinner$1);
      return undefined;
    }
    spinner$1.success();
    return result;
  }
}

async function getSocketConfig(absoluteConfigPath) {
  const socketConfig = await config$A.readSocketConfig(absoluteConfigPath).catch(cause => {
    if (cause && typeof cause === 'object' && cause instanceof config$A.SocketValidationError) {
      // Inspired by workbox-build:
      // https://github.com/GoogleChrome/workbox/blob/95f97a207fd51efb3f8a653f6e3e58224183a778/packages/workbox-build/src/lib/validate-options.ts#L68-L71
      const betterErrors = betterAjvErrors.betterAjvErrors({
        basePath: 'config',
        data: cause.data,
        errors: cause.validationErrors,
        schema: cause.schema
      });
      throw new index.InputError('The socket.yml config is not valid', betterErrors.map(err => `[${err.path}] ${err.message}.${err.suggestion ? err.suggestion : ''}`).join('\n'));
    } else {
      throw new Error('Failed to read socket.yml config', {
        cause
      });
    }
  });
  return socketConfig;
}

const MAX_TIMEOUT_RETRY = 5;
const HTTP_CODE_TIMEOUT = 524;
async function fetchReportData(reportId, includeAllIssues, strict) {
  const socketSdk = await index.setupSdk();
  const spinner$1 = new spinner.Spinner({
    text: `Fetching report with ID ${reportId} (this could take a while)`
  }).start();
  let result;
  for (let retry = 1; !result; ++retry) {
    try {
      // eslint-disable-next-line no-await-in-loop
      result = await handleApiCall(socketSdk.getReport(reportId), 'fetching report');
    } catch (err) {
      if (retry >= MAX_TIMEOUT_RETRY || !(err instanceof Error) || err.cause?.cause?.response?.statusCode !== HTTP_CODE_TIMEOUT) {
        throw err;
      }
    }
  }
  if (!result.success) {
    return handleUnsuccessfulApiResponse('getReport', result, spinner$1);
  }

  // Conclude the status of the API call

  if (strict) {
    if (result.data.healthy) {
      spinner$1.success('Report result is healthy and great!');
    } else {
      spinner$1.error('Report result deemed unhealthy for project');
    }
  } else if (!result.data.healthy) {
    const severityCount = getSeverityCount(result.data.issues, includeAllIssues ? undefined : 'high');
    const issueSummary = formatSeverityCount(severityCount);
    spinner$1.success(`Report has these issues: ${issueSummary}`);
  } else {
    spinner$1.success('Report has no issues');
  }
  return result.data;
}

function formatReportDataOutput(reportId, data, commandName, outputJson, outputMarkdown, strict) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
  } else {
    const format = new index.ColorOrMarkdown(outputMarkdown);
    console.log('\nDetailed info on socket.dev: ' + format.hyperlink(reportId, data.url, {
      fallbackToUrl: true
    }));
    if (!outputMarkdown) {
      console.log(colors.dim(`\nOr rerun ${colors.italic(commandName)} using the ${colors.italic('--json')} flag to get full JSON output`));
    }
  }
  if (strict && !data.healthy) {
    process$1.exit(1);
  }
}

async function viewReport(reportId, {
  all,
  commandName,
  json,
  markdown,
  strict
}) {
  const result = await fetchReportData(reportId, all, strict);
  if (result) {
    formatReportDataOutput(reportId, result, commandName, json, markdown, strict);
  }
}

const config$d = {
  commandName: 'create',
  description: 'Create a project report',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags,
    dryRun: {
      type: 'boolean',
      default: false,
      description: 'Only output what will be done without actually doing it'
    },
    view: {
      type: 'boolean',
      shortFlag: 'v',
      default: false,
      description: 'Will wait for and return the created report'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <paths-to-package-folders-and-files>

    Uploads the specified "package.json" and lock files for JavaScript, Python, and Go dependency manifests.
    If any folder is specified, the ones found in there recursively are uploaded.

    Supports globbing such as "**/package.json", "**/requirements.txt", "**/pyproject.toml", and "**/go.mod".

    Ignores any file specified in your project's ".gitignore", your project's
    "socket.yml" file's "projectIgnorePaths" and also has a sensible set of
    default ignores from the "ignore-by-default" module.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} .
      $ ${command} '**/package.json'
      $ ${command} /path/to/a/package.json /path/to/another/package.json
      $ ${command} . --view --json
  `
};
const cmdReportCreate = {
  description: config$d.description,
  hidden: config$d.hidden,
  run: run$d
};
async function run$d(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$d,
    importMeta,
    parentName
  });

  // TODO: Allow setting a custom cwd and/or configFile path?
  const cwd = process$1.cwd();
  const absoluteConfigPath = path.join(cwd, 'socket.yml');
  const dryRun = Boolean(cli.flags['dryRun']);
  const json = Boolean(cli.flags['json']);
  const markdown = Boolean(cli.flags['markdown']);
  const strict = Boolean(cli.flags['strict']);
  const includeAllIssues = Boolean(cli.flags['all']);
  const view = Boolean(cli.flags['view']);
  const socketConfig = await getSocketConfig(absoluteConfigPath);
  const result = await createReport(socketConfig, cli.input, {
    cwd,
    dryRun
  });
  const commandName = `${parentName} ${config$d.commandName}`;
  if (dryRun && view) {
    console.log('[dryrun] Ignoring view flag since no report was actually generated');
  }
  if (result?.success) {
    if (view) {
      const reportId = result.data.id;
      await viewReport(reportId, {
        all: includeAllIssues,
        commandName,
        json,
        markdown,
        strict
      });
    } else if (json) {
      console.log(JSON.stringify(result.data, undefined, 2));
      return;
    } else {
      const format = new index.ColorOrMarkdown(markdown);
      console.log(`New report: ${format.hyperlink(result.data.id, result.data.url, {
        fallbackToUrl: true
      })}`);
    }
  }
}

const config$c = {
  commandName: 'view',
  description: 'View a project report',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <report-identifier>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} QXU8PmK7LfH608RAwfIKdbcHgwEd_ZeWJ9QEGv05FJUQ
  `
};
const cmdReportView = {
  description: config$c.description,
  hidden: config$c.hidden,
  run: run$c
};
async function run$c(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$c,
    importMeta,
    parentName
  });
  const [reportId, ...extraInput] = cli.input;

  // Validate the input.
  if (extraInput.length || !reportId) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Need at least one report ID ${!reportId ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Can only handle a single report ID ${extraInput.length < 2 ? colors.red(`(received ${extraInput.length}!)`) : colors.green('(ok)')}\n
    `);
    cli.showHelp();
    return;
  }
  await viewReport(reportId, {
    all: Boolean(cli.flags['all']),
    commandName: `${parentName} ${config$c.commandName}`,
    json: Boolean(cli.flags['json']),
    markdown: Boolean(cli.flags['markdown']),
    strict: Boolean(cli.flags['strict'])
  });
}

const description$2 = '[Deprecated] Project report related commands';
const cmdReport = {
  description: description$2,
  async run(argv, importMeta, {
    parentName
  }) {
    await meowWithSubcommands({
      create: cmdReportCreate,
      view: cmdReportView
    }, {
      argv,
      description: description$2,
      importMeta,
      name: parentName + ' report'
    });
  }
};

async function createRepo({
  apiToken,
  default_branch,
  description,
  homepage,
  orgSlug,
  outputJson,
  outputMarkdown,
  repoName,
  visibility
}) {
  const spinnerText = 'Creating repository... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.createOrgRepo(orgSlug, {
    outputJson,
    outputMarkdown,
    orgSlug,
    name: repoName,
    description,
    homepage,
    default_branch,
    visibility
  }), 'creating repository');
  if (result.success) {
    spinner$1.success('Repository created successfully');
  } else {
    handleUnsuccessfulApiResponse('createOrgRepo', result, spinner$1);
  }
}

const config$b = {
  commandName: 'create',
  description: 'Create a repository in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    repoName: {
      type: 'string',
      shortFlag: 'n',
      default: '',
      description: 'Repository name'
    },
    repoDescription: {
      type: 'string',
      shortFlag: 'd',
      default: '',
      description: 'Repository description'
    },
    homepage: {
      type: 'string',
      shortFlag: 'h',
      default: '',
      description: 'Repository url'
    },
    defaultBranch: {
      type: 'string',
      shortFlag: 'b',
      default: 'main',
      description: 'Repository default branch'
    },
    visibility: {
      type: 'string',
      shortFlag: 'v',
      default: 'private',
      description: 'Repository visibility (Default Private)'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg --repoName=test-repo
  `
};
const cmdReposCreate = {
  description: config$b.description,
  hidden: config$b.hidden,
  run: run$b
};
async function run$b(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$b,
    importMeta,
    parentName
  });
  const repoName = cli.flags['repoName'];
  const [orgSlug = ''] = cli.input;
  if (!repoName || typeof repoName !== 'string' || !orgSlug) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Repository name using --repoName ${!repoName ? colors.red('(missing!)') : typeof repoName !== 'string' ? colors.red('(invalid!)') : colors.green('(ok)')}\n
    `);
    cli.showHelp();
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await createRepo({
    outputJson: Boolean(cli.flags['json']),
    outputMarkdown: Boolean(cli.flags['markdown']),
    orgSlug,
    repoName,
    description: String(cli.flags['repoDescription'] || ''),
    homepage: String(cli.flags['homepage'] || ''),
    default_branch: String(cli.flags['defaultBranch'] || ''),
    visibility: String(cli.flags['visibility'] || 'private'),
    apiToken
  });
}

async function deleteRepo(orgSlug, repoName, apiToken) {
  const spinnerText = 'Deleting repository... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.deleteOrgRepo(orgSlug, repoName), 'deleting repository');
  if (result.success) {
    spinner$1.success('Repository deleted successfully');
  } else {
    handleUnsuccessfulApiResponse('deleteOrgRepo', result, spinner$1);
  }
}

const config$a = {
  commandName: 'delete',
  description: 'Delete a repository in an organization',
  hidden: false,
  flags: {},
  help: (command, _config) => `
    Usage
      $ ${command} <org slug> <repo slug>

    Examples
      $ ${command} FakeOrg test-repo
  `
};
const cmdReposDelete = {
  description: config$a.description,
  hidden: config$a.hidden,
  run: run$a
};
async function run$a(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$a,
    importMeta,
    parentName
  });
  const [orgSlug = '', repoName = ''] = cli.input;
  if (!orgSlug || !repoName) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Repository name as the second argument ${!repoName ? colors.red('(missing!)') : typeof repoName !== 'string' ? colors.red('(invalid!)') : colors.green('(ok)')}\n
      - At least one TARGET (e.g. \`.\` or \`./package.json\`
    `);
    cli.showHelp();
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await deleteRepo(orgSlug, repoName, apiToken);
}

// @ts-ignore
async function listRepos({
  apiToken,
  direction,
  orgSlug,
  outputJson,
  outputMarkdown,
  page,
  per_page,
  sort
}) {
  const spinnerText = 'Listing repositories... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getOrgRepoList(orgSlug, {
    outputJson,
    outputMarkdown,
    orgSlug,
    sort,
    direction,
    per_page,
    page
  }), 'listing repositories');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgRepoList', result, spinner$1);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: colors.magenta('ID')
    }, {
      field: 'name',
      name: colors.magenta('Name')
    }, {
      field: 'visibility',
      name: colors.magenta('Visibility')
    }, {
      field: 'default_branch',
      name: colors.magenta('Default branch')
    }, {
      field: 'archived',
      name: colors.magenta('Archived')
    }]
  };
  spinner$1.stop(chalkTable(options, result.data.results));
}

const config$9 = {
  commandName: 'list',
  description: 'List repositories in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    sort: {
      type: 'string',
      shortFlag: 's',
      default: 'created_at',
      description: 'Sorting option'
    },
    direction: {
      type: 'string',
      default: 'desc',
      description: 'Direction option'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Number of results per page'
    },
    page: {
      type: 'number',
      shortFlag: 'p',
      default: 1,
      description: 'Page number'
    },
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg
  `
};
const cmdReposList = {
  description: config$9.description,
  hidden: config$9.hidden,
  run: run$9
};
async function run$9(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$9,
    importMeta,
    parentName
  });
  const [orgSlug = ''] = cli.input;
  if (!orgSlug) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - At least one TARGET (e.g. \`.\` or \`./package.json\`
    `);
    cli.showHelp();
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await listRepos({
    apiToken,
    outputJson: Boolean(cli.flags['json']),
    outputMarkdown: Boolean(cli.flags['markdown']),
    orgSlug,
    sort: String(cli.flags['sort'] || 'created_at'),
    direction: cli.flags['direction'] === 'asc' ? 'asc' : 'desc',
    page: Number(cli.flags['page']) || 1,
    per_page: Number(cli.flags['perPage']) || 30
  });
}

async function updateRepo({
  apiToken,
  default_branch,
  description,
  homepage,
  orgSlug,
  outputJson,
  outputMarkdown,
  repoName,
  visibility
}) {
  const spinnerText = 'Updating repository... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.updateOrgRepo(orgSlug, repoName, {
    outputJson,
    outputMarkdown,
    orgSlug,
    name: repoName,
    description,
    homepage,
    default_branch,
    visibility
  }), 'updating repository');
  if (result.success) {
    spinner$1.success('Repository updated successfully');
  } else {
    handleUnsuccessfulApiResponse('updateOrgRepo', result, spinner$1);
  }
}

const config$8 = {
  commandName: 'create',
  description: 'Update a repository in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    repoName: {
      type: 'string',
      shortFlag: 'n',
      default: '',
      description: 'Repository name'
    },
    repoDescription: {
      type: 'string',
      shortFlag: 'd',
      default: '',
      description: 'Repository description'
    },
    homepage: {
      type: 'string',
      shortFlag: 'h',
      default: '',
      description: 'Repository url'
    },
    defaultBranch: {
      type: 'string',
      shortFlag: 'b',
      default: 'main',
      description: 'Repository default branch'
    },
    visibility: {
      type: 'string',
      shortFlag: 'v',
      default: 'private',
      description: 'Repository visibility (Default Private)'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg
  `
};
const cmdReposUpdate = {
  description: config$8.description,
  hidden: config$8.hidden,
  run: run$8
};
async function run$8(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$8,
    importMeta,
    parentName
  });
  const repoName = cli.flags['repoName'];
  const [orgSlug = ''] = cli.input;
  if (!repoName || typeof repoName !== 'string' || !orgSlug) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Repository name using --repoName ${!repoName ? colors.red('(missing!)') : typeof repoName !== 'string' ? colors.red('(invalid!)') : colors.green('(ok)')}\n
      - At least one TARGET (e.g. \`.\` or \`./package.json\`
    `);
    cli.showHelp();
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await updateRepo({
    apiToken,
    outputJson: Boolean(cli.flags['json']),
    outputMarkdown: Boolean(cli.flags['markdown']),
    orgSlug,
    repoName,
    description: String(cli.flags['repoDescription'] || ''),
    homepage: String(cli.flags['homepage'] || ''),
    default_branch: String(cli.flags['defaultBranch'] || ''),
    visibility: String(cli.flags['visibility'] || 'private')
  });
}

// @ts-ignore
async function viewRepo(orgSlug, repoName, apiToken) {
  const spinnerText = 'Fetching repository... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getOrgRepo(orgSlug, repoName), 'fetching repository');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgRepo', result, spinner$1);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: colors.magenta('ID')
    }, {
      field: 'name',
      name: colors.magenta('Name')
    }, {
      field: 'visibility',
      name: colors.magenta('Visibility')
    }, {
      field: 'default_branch',
      name: colors.magenta('Default branch')
    }, {
      field: 'homepage',
      name: colors.magenta('Homepage')
    }, {
      field: 'archived',
      name: colors.magenta('Archived')
    }, {
      field: 'created_at',
      name: colors.magenta('Created at')
    }]
  };
  spinner$1.stop(chalkTable(options, [result.data]));
}

const config$7 = {
  commandName: 'view',
  description: 'View repositories in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg
  `
};
const cmdReposView = {
  description: config$7.description,
  hidden: config$7.hidden,
  run: run$7
};
async function run$7(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$7,
    importMeta,
    parentName
  });
  const repoName = cli.flags['repoName'];
  const [orgSlug = ''] = cli.input;
  if (!repoName || typeof repoName !== 'string' || !orgSlug) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Repository name using --repoName ${!repoName ? colors.red('(missing!)') : typeof repoName !== 'string' ? colors.red('(invalid!)') : colors.green('(ok)')}\n
    `);
    cli.showHelp();
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await viewRepo(orgSlug, repoName, apiToken);
}

const description$1 = 'Repositories related commands';
const cmdRepos = {
  description: description$1,
  async run(argv, importMeta, {
    parentName
  }) {
    await meowWithSubcommands({
      cmdReposCreate,
      cmdReposView,
      cmdReposList,
      cmdReposDelete,
      cmdReposUpdate
    }, {
      argv,
      description: description$1,
      importMeta,
      name: `${parentName} repo`
    });
  }
};

async function createFullScan({
  apiToken,
  branchName,
  commitHash: _commitHash,
  commitMessage,
  committers: _committers,
  cwd,
  defaultBranch,
  orgSlug,
  packagePaths,
  pendingHead,
  pullRequest: _pullRequest,
  repoName,
  tmp
}) {
  const spinnerText = 'Creating a scan... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.createOrgFullScan(orgSlug, {
    repo: repoName,
    branch: branchName,
    commit_message: commitMessage,
    make_default_branch: defaultBranch,
    set_as_pending_head: pendingHead,
    tmp
  }, packagePaths, cwd), 'Creating scan');
  if (!result.success) {
    handleUnsuccessfulApiResponse('CreateOrgFullScan', result, spinner$1);
    return;
  }
  spinner$1.success('Scan created successfully');
  const link = colors.underline(colors.cyan(`${result.data.html_report_url}`));
  console.log(`Available at: ${link}`);
  const rl = readline.createInterface({
    input: process$1.stdin,
    output: process$1.stdout
  });
  const answer = await rl.question('Would you like to open it in your browser? (y/n)');
  if (answer.toLowerCase() === 'y') {
    await vendor.open(`${result.data.html_report_url}`);
  }
  rl.close();
}

const config$6 = {
  commandName: 'create',
  description: 'Create a scan',
  hidden: false,
  flags: {
    repo: {
      type: 'string',
      shortFlag: 'r',
      default: '',
      description: 'Repository name'
    },
    branch: {
      type: 'string',
      shortFlag: 'b',
      default: '',
      description: 'Branch name'
    },
    commitMessage: {
      type: 'string',
      shortFlag: 'm',
      default: '',
      description: 'Commit message'
    },
    commitHash: {
      type: 'string',
      shortFlag: 'ch',
      default: '',
      description: 'Commit hash'
    },
    cwd: {
      type: 'string',
      description: 'working directory, defaults to process.cwd()'
    },
    pullRequest: {
      type: 'number',
      shortFlag: 'pr',
      description: 'Commit hash'
    },
    committers: {
      type: 'string',
      shortFlag: 'c',
      default: '',
      description: 'Committers'
    },
    defaultBranch: {
      type: 'boolean',
      shortFlag: 'db',
      default: false,
      description: 'Make default branch'
    },
    pendingHead: {
      type: 'boolean',
      shortFlag: 'ph',
      default: false,
      description: 'Set as pending head'
    },
    tmp: {
      type: 'boolean',
      shortFlag: 't',
      default: false,
      description: 'Set the visibility (true/false) of the scan in your dashboard'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [...options] <org> <TARGET> [TARGET...]

    Where TARGET is a FILE or DIR that _must_ be inside the CWD.

    When a FILE is given only that FILE is targeted. Otherwise any eligible
    files in the given DIR will be considered.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} --repo=test-repo --branch=main FakeOrg ./package.json
  `
};
const cmdScanCreate = {
  description: config$6.description,
  hidden: config$6.hidden,
  run: run$6
};
async function run$6(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$6,
    importMeta,
    parentName
  });
  const [orgSlug = '', ...targets] = cli.input;
  const cwd = cli.flags['cwd'] && cli.flags['cwd'] !== 'process.cwd()' ? String(cli.flags['cwd']) : process$1.cwd();
  const socketSdk = await index.setupSdk();
  const supportedFiles = await socketSdk.getReportSupportedFiles().then(res => {
    if (!res.success) handleUnsuccessfulApiResponse('getReportSupportedFiles', res, new spinner.Spinner());
    // TODO: verify type at runtime? Consider it trusted data and assume type?
    return res.data;
  }).catch(cause => {
    throw new Error('Failed getting supported files for report', {
      cause
    });
  });
  const packagePaths = await npmPaths.getPackageFilesFullScans(cwd, targets, supportedFiles);
  const {
    branch: branchName,
    repo: repoName
  } = cli.flags;
  if (!orgSlug || !repoName || !branchName || !packagePaths.length) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
    - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
    - Repository name using --repo ${!repoName ? colors.red('(missing!)') : colors.green('(ok)')}\n
    - Branch name using --branch ${!branchName ? colors.red('(missing!)') : colors.green('(ok)')}\n
    - At least one TARGET (e.g. \`.\` or \`./package.json\`) ${!packagePaths.length ? colors.red(targets.length > 0 ? '(TARGET' + (targets.length ? 's' : '') + ' contained no matching/supported files!)' : '(missing)') : colors.green('(ok)')}`);
    config$6.help(parentName, config$6);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await createFullScan({
    apiToken,
    orgSlug,
    repoName: repoName,
    branchName: branchName,
    commitMessage: cli.flags['commitMessage'] ?? '',
    defaultBranch: Boolean(cli.flags['defaultBranch']),
    pendingHead: Boolean(cli.flags['pendingHead']),
    tmp: Boolean(cli.flags['tmp']),
    packagePaths,
    cwd,
    commitHash: cli.flags['commitHash'] ?? '',
    committers: cli.flags['committers'] ?? '',
    pullRequest: cli.flags['pullRequest'] ?? undefined
  });
}

async function deleteOrgFullScan(orgSlug, fullScanId, apiToken) {
  const spinnerText = 'Deleting scan...';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.deleteOrgFullScan(orgSlug, fullScanId), 'Deleting scan');
  if (result.success) {
    spinner$1.success('Scan deleted successfully');
  } else {
    handleUnsuccessfulApiResponse('deleteOrgFullScan', result, spinner$1);
  }
}

const config$5 = {
  commandName: 'del',
  description: 'Delete a scan',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug> <scan ID>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `
};
const cmdScanDelete = {
  description: config$5.description,
  hidden: config$5.hidden,
  run: run$5
};
async function run$5(argv, importMeta, {
  parentName
}) {
  const cli = vendor.meow(config$5.help(parentName, config$5), {
    argv,
    description: config$5.description,
    importMeta,
    flags: config$5.flags
  });
  const [orgSlug = '', fullScanId = ''] = cli.input;
  if (!orgSlug || !fullScanId) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Full Scan ID to delete as second argument ${!fullScanId ? colors.red('(missing!)') : colors.green('(ok)')}
    `);
    config$5.help(parentName, config$5);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await deleteOrgFullScan(orgSlug, fullScanId, apiToken);
}

// @ts-ignore
async function listFullScans(orgSlug, input, apiToken) {
  const spinnerText = 'Listing scans... \n';
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getOrgFullScanList(orgSlug, input), 'Listing scans');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgFullScanList', result, spinner$1);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: colors.magenta('ID')
    }, {
      field: 'report_url',
      name: colors.magenta('Scan URL')
    }, {
      field: 'branch',
      name: colors.magenta('Branch')
    }, {
      field: 'created_at',
      name: colors.magenta('Created at')
    }]
  };
  const formattedResults = result.data.results.map(d => {
    return {
      id: d.id,
      report_url: colors.underline(`${d.html_report_url}`),
      created_at: d.created_at ? new Date(d.created_at).toLocaleDateString('en-us', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      }) : '',
      branch: d.branch
    };
  });
  spinner$1.stop(`Listing scans for: ${orgSlug}`);
  console.log(chalkTable(options, formattedResults));
}

const config$4 = {
  commandName: 'list',
  description: 'List the full scans for an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    sort: {
      type: 'string',
      shortFlag: 's',
      default: 'created_at',
      description: 'Sorting option (`name` or `created_at`) - default is `created_at`'
    },
    direction: {
      type: 'string',
      shortFlag: 'd',
      default: 'desc',
      description: 'Direction option (`desc` or `asc`) - Default is `desc`'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Results per page - Default is 30'
    },
    page: {
      type: 'number',
      shortFlag: 'p',
      default: 1,
      description: 'Page number - Default is 1'
    },
    fromTime: {
      type: 'string',
      shortFlag: 'f',
      default: '',
      description: 'From time - as a unix timestamp'
    },
    untilTime: {
      type: 'string',
      shortFlag: 'u',
      default: '',
      description: 'Until time - as a unix timestamp'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg
  `
};
const cmdScanList = {
  description: config$4.description,
  hidden: config$4.hidden,
  run: run$4
};
async function run$4(argv, importMeta, {
  parentName
}) {
  const cli = vendor.meow(config$4.help(parentName, config$4), {
    argv,
    description: config$4.description,
    importMeta,
    flags: config$4.flags
  });
  const orgSlug = cli.input[0];
  if (!orgSlug) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
    - Org name as the argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}`);
    config$4.help(parentName, config$4);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await listFullScans(orgSlug,
  // TODO: refine this object to what we need
  {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    sort: cli.flags['sort'],
    direction: cli.flags['direction'],
    per_page: cli.flags['perPage'],
    page: cli.flags['page'],
    from_time: cli.flags['fromTime'],
    until_time: cli.flags['untilTime']
  }, apiToken);
}

async function getOrgScanMetadata(orgSlug, scanId, apiToken) {
  const spinnerText = "Getting scan's metadata... \n";
  const spinner$1 = new spinner.Spinner({
    text: spinnerText
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const result = await handleApiCall(socketSdk.getOrgFullScanMetadata(orgSlug, scanId), 'Listing scans');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgFullScanMetadata', result, spinner$1);
    return;
  }
  spinner$1.stop('Scan metadata:');
  console.log(result.data);
}

const config$3 = {
  commandName: 'metadata',
  description: "Get a full scan's metadata",
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug> <scan id>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `
};
const cmdScanMetadata = {
  description: config$3.description,
  hidden: config$3.hidden,
  run: run$3
};
async function run$3(argv, importMeta, {
  parentName
}) {
  const cli = vendor.meow(config$3.help(parentName, config$3), {
    argv,
    description: config$3.description,
    importMeta,
    flags: config$3.flags
  });
  const [orgSlug = '', fullScanId = ''] = cli.input;
  if (!orgSlug || !fullScanId) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Full Scan ID to inspect as second argument ${!fullScanId ? colors.red('(missing!)') : colors.green('(ok)')}
    `);
    config$3.help(parentName, config$3);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await getOrgScanMetadata(orgSlug, fullScanId, apiToken);
}

async function getFullScan(orgSlug, fullScanId, file, apiToken) {
  const spinner$1 = new spinner.Spinner({
    text: 'Streaming scan...'
  }).start();
  const socketSdk = await index.setupSdk(apiToken);
  const data = await handleApiCall(socketSdk.getOrgFullScan(orgSlug, fullScanId, file === '-' ? undefined : file), 'Streaming a scan');
  if (data?.success) {
    spinner$1.stop(file ? `Full scan details written to ${file}` : '');
  } else {
    handleUnsuccessfulApiResponse('getOrgFullScan', data, spinner$1);
  }
  return data;
}

const config$2 = {
  commandName: 'stream',
  description: 'Stream the output of a scan',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug> <scan ID> [path to output file]

    When no output path is given the contents is sent to stdout.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0 ./stream.txt
  `
};
const cmdScanStream = {
  description: config$2.description,
  hidden: config$2.hidden,
  run: run$2
};
async function run$2(argv, importMeta, {
  parentName
}) {
  const cli = vendor.meow(config$2.help(parentName, config$2), {
    argv,
    description: config$2.description,
    importMeta,
    flags: config$2.flags
  });
  const [orgSlug = '', fullScanId = '', file = '-'] = cli.input;
  if (!orgSlug || !fullScanId) {
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
      - Org name as the first argument ${!orgSlug ? colors.red('(missing!)') : colors.green('(ok)')}\n
      - Full Scan ID to fetch as second argument ${!fullScanId ? colors.red('(missing!)') : colors.green('(ok)')}
    `);
    config$2.help(parentName, config$2);
    return;
  }
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await getFullScan(orgSlug, fullScanId, file, apiToken);
}

const description = 'Scans related commands';
const cmdScan = {
  description,
  async run(argv, importMeta, {
    parentName
  }) {
    await meowWithSubcommands({
      create: cmdScanCreate,
      stream: cmdScanStream,
      list: cmdScanList,
      del: cmdScanDelete,
      metadata: cmdScanMetadata
    }, {
      argv,
      description,
      importMeta,
      name: parentName + ' scan'
    });
  }
};

async function getThreatFeed({
  apiToken,
  direction,
  filter,
  outputJson,
  page,
  perPage
}) {
  const spinner$1 = new spinner.Spinner({
    text: 'Looking up the threat feed'
  }).start();
  const formattedQueryParams = formatQueryParams({
    per_page: perPage,
    page,
    direction,
    filter
  }).join('&');
  const response = await queryAPI(`threat-feed?${formattedQueryParams}`, apiToken);
  const data = await response.json();
  spinner$1.stop();
  if (outputJson) {
    console.log(data);
    return;
  }
  const screen = new ScreenWidget();
  const table = new TableWidget({
    keys: 'true',
    fg: 'white',
    selectedFg: 'white',
    selectedBg: 'magenta',
    interactive: 'true',
    label: 'Threat feed',
    width: '100%',
    height: '100%',
    border: {
      type: 'line',
      fg: 'cyan'
    },
    columnSpacing: 3,
    //in chars
    columnWidth: [9, 30, 10, 17, 13, 100] /*in chars*/
  });

  // allow control the table with the keyboard
  table.focus();
  screen.append(table);
  const formattedOutput = formatResults(data.results);
  table.setData({
    headers: ['Ecosystem', 'Name', 'Version', 'Threat type', 'Detected at', 'Details'],
    data: formattedOutput
  });
  screen.render();
  screen.key(['escape', 'q', 'C-c'], () => process$1.exit(0));
}
function formatResults(data) {
  return data.map(d => {
    const ecosystem = d.purl.split('pkg:')[1].split('/')[0];
    const name = d.purl.split('/')[1].split('@')[0];
    const version = d.purl.split('@')[1];
    const timeStart = new Date(d.createdAt).getMilliseconds();
    const timeEnd = Date.now();
    const diff = getHourDiff(timeStart, timeEnd);
    const hourDiff = diff > 0 ? `${diff} hours ago` : `${getMinDiff(timeStart, timeEnd)} minutes ago`;
    return [ecosystem, decodeURIComponent(name), version, d.threatType, hourDiff, d.locationHtmlUrl];
  });
}
function formatQueryParams(params) {
  return Object.entries(params).map(entry => `${entry[0]}=${entry[1]}`);
}
function getHourDiff(start, end) {
  return Math.floor((end - start) / 3600000);
}
function getMinDiff(start, end) {
  return Math.floor((end - start) / 60000);
}

const config$1 = {
  commandName: 'threat-feed',
  description: 'Look up the threat feed',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Number of items per page'
    },
    page: {
      type: 'string',
      shortFlag: 'p',
      default: '1',
      description: 'Page token'
    },
    direction: {
      type: 'string',
      shortFlag: 'd',
      default: 'desc',
      description: 'Order asc or desc by the createdAt attribute.'
    },
    filter: {
      type: 'string',
      shortFlag: 'f',
      default: 'mal',
      description: 'Filter what type of threats to return'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}
      $ ${command} --perPage=5 --page=2 --direction=asc --filter=joke
  `
};
const cmdThreatFeed = {
  description: config$1.description,
  hidden: config$1.hidden,
  run: run$1
};
async function run$1(argv, importMeta, {
  parentName
}) {
  const cli = meowOrExit({
    argv,
    config: config$1,
    importMeta,
    parentName
  });
  const apiToken = index.getDefaultToken();
  if (!apiToken) {
    throw new index.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  await getThreatFeed({
    apiToken,
    direction: String(cli.flags['direction'] || 'desc'),
    filter: String(cli.flags['filter'] || 'mal'),
    outputJson: Boolean(cli.flags['json']),
    page: String(cli.flags['filter'] || '1'),
    perPage: Number(cli.flags['per_page'] || 0)
  });
}

function addSocketWrapper(file) {
  return fs.appendFile(file, 'alias npm="socket npm"\nalias npx="socket npx"\n', err => {
    if (err) {
      return new Error(`There was an error setting up the alias: ${err}`);
    }
    // TODO: pretty sure you need to source the file or restart
    //       any terminal session before changes are reflected.
    console.log(`
The alias was added to ${file}. Running 'npm install' will now be wrapped in Socket's "safe npm" 
If you want to disable it at any time, run \`socket wrapper --disable\`
`);
  });
}

function checkSocketWrapperSetup(file) {
  const fileContent = fs.readFileSync(file, 'utf8');
  const linesWithSocketAlias = fileContent.split('\n').filter(l => l === 'alias npm="socket npm"' || l === 'alias npx="socket npx"');
  if (linesWithSocketAlias.length) {
    console.log(`The Socket npm/npx wrapper is set up in your bash profile (${file}).`);
    return true;
  }
  return false;
}

const HOME_DIR$1 = os.homedir();
const BASH_FILE$1 = `${HOME_DIR$1}/.bashrc`;
const ZSH_BASH_FILE$1 = `${HOME_DIR$1}/.zshrc`;
function postinstallWrapper() {
  const socketWrapperEnabled = fs.existsSync(BASH_FILE$1) && checkSocketWrapperSetup(BASH_FILE$1) || fs.existsSync(ZSH_BASH_FILE$1) && checkSocketWrapperSetup(ZSH_BASH_FILE$1);
  if (!socketWrapperEnabled) {
    installSafeNpm(`The Socket CLI is now successfully installed! 

      To better protect yourself against supply-chain attacks, our "safe npm" wrapper can warn you about malicious packages whenever you run 'npm install'.

      Do you want to install "safe npm" (this will create an alias to the socket-npm command)? (y/n)`);
  }
}
function installSafeNpm(query) {
  console.log(`
 _____         _       _
|   __|___ ___| |_ ___| |_
|__   | . |  _| '_| -_|  _|
|_____|___|___|_,_|___|_|

`);
  const rl = readline$1.createInterface({
    input: process$1.stdin,
    output: process$1.stdout
  });
  return askQuestion(rl, query);
}
function askQuestion(rl, query) {
  rl.question(query, ans => {
    if (ans.toLowerCase() === 'y') {
      try {
        if (fs.existsSync(BASH_FILE$1)) {
          addSocketWrapper(BASH_FILE$1);
        }
        if (fs.existsSync(ZSH_BASH_FILE$1)) {
          addSocketWrapper(ZSH_BASH_FILE$1);
        }
      } catch (e) {
        throw new Error(`There was an issue setting up the alias: ${e}`);
      }
      rl.close();
    } else if (ans.toLowerCase() !== 'n') {
      askQuestion(rl, 'Incorrect input: please enter either y (yes) or n (no): ');
    } else {
      rl.close();
    }
  });
}

function removeSocketWrapper(file) {
  return fs.readFile(file, 'utf8', function (err, data) {
    if (err) {
      console.error(`There was an error removing the alias: ${err}`);
      return;
    }
    const linesWithoutSocketAlias = data.split('\n').filter(l => l !== 'alias npm="socket npm"' && l !== 'alias npx="socket npx"');
    const updatedFileContent = linesWithoutSocketAlias.join('\n');
    fs.writeFile(file, updatedFileContent, function (err) {
      if (err) {
        console.log(err);
        return;
      } else {
        // TODO: pretty sure you need to source the file or restart
        //       any terminal session before changes are reflected.
        console.log(`\nThe alias was removed from ${file}. Running 'npm install' will now run the standard npm command.\n`);
      }
    });
  });
}

const HOME_DIR = os.homedir();
const BASH_FILE = `${HOME_DIR}/.bashrc`;
const ZSH_BASH_FILE = `${HOME_DIR}/.zshrc`;
const config = {
  commandName: 'wrapper',
  description: 'Enable or disable the Socket npm/npx wrapper',
  hidden: false,
  flags: {
    enable: {
      type: 'boolean',
      default: false,
      description: 'Enables the Socket npm/npx wrapper'
    },
    disable: {
      type: 'boolean',
      default: false,
      description: 'Disables the Socket npm/npx wrapper'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <flag>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} --enable
      $ ${command} --disable
  `
};
const cmdWrapper = {
  description: config.description,
  hidden: config.hidden,
  run
};
async function run(argv, importMeta, {
  parentName
}) {
  // I don't think meow would mess with this but ...
  if (argv[0] === '--postinstall') {
    postinstallWrapper();
    return;
  }
  const cli = meowOrExit({
    argv,
    config,
    importMeta,
    parentName
  });
  const {
    disable,
    enable
  } = cli.flags;
  if (!enable && !disable) {
    cli.showHelp();
    return;
  }
  if (enable) {
    if (fs.existsSync(BASH_FILE)) {
      const socketWrapperEnabled = checkSocketWrapperSetup(BASH_FILE);
      !socketWrapperEnabled && addSocketWrapper(BASH_FILE);
    }
    if (fs.existsSync(ZSH_BASH_FILE)) {
      const socketWrapperEnabled = checkSocketWrapperSetup(ZSH_BASH_FILE);
      !socketWrapperEnabled && addSocketWrapper(ZSH_BASH_FILE);
    }
  } else {
    if (fs.existsSync(BASH_FILE)) {
      removeSocketWrapper(BASH_FILE);
    }
    if (fs.existsSync(ZSH_BASH_FILE)) {
      removeSocketWrapper(ZSH_BASH_FILE);
    }
  }
  if (!fs.existsSync(BASH_FILE) && !fs.existsSync(ZSH_BASH_FILE)) {
    console.error('There was an issue setting up the alias in your bash profile');
  }
}

const {
  SOCKET,
  rootPkgJsonPath
} = constants;

// TODO: Add autocompletion using https://socket.dev/npm/package/omelette
void (async () => {
  await vendor.updater({
    name: SOCKET,
    version: require(rootPkgJsonPath).version,
    ttl: 86_400_000 /* 24 hours in milliseconds */
  });
  try {
    await meowWithSubcommands({
      action: cmdAction,
      cdxgen: cmdCdxgen,
      fix: cmdFix,
      info: cmdInfo,
      login: cmdLogin,
      logout: cmdLogout,
      npm: cmdNpm,
      npx: cmdNpx,
      oops: cmdOops,
      optimize: cmdOptimize,
      organization: cmdOrganizations,
      'raw-npm': cmdRawNpm,
      'raw-npx': cmdRawNpx,
      report: cmdReport,
      wrapper: cmdWrapper,
      scan: cmdScan,
      'audit-log': cmdAuditLog,
      repos: cmdRepos,
      dependencies: cmdScanCreate$1,
      analytics: cmdAnalytics,
      'diff-scan': cmdDiffScan,
      'threat-feed': cmdThreatFeed,
      manifest: cmdManifest
    }, {
      aliases: {
        ci: {
          description: 'Alias for "report create --view --strict"',
          argv: ['report', 'create', '--view', '--strict']
        }
      },
      argv: process$1.argv.slice(2),
      name: SOCKET,
      importMeta: {
        url: `${require$$0.pathToFileURL(__filename)}`
      }
    });
  } catch (e) {
    process$1.exitCode = 1;
    let errorBody;
    let errorTitle;
    let errorMessage = '';
    if (e instanceof index.AuthError) {
      errorTitle = 'Authentication error';
      errorMessage = e.message;
    } else if (e instanceof index.InputError) {
      errorTitle = 'Invalid input';
      errorMessage = e.message;
      errorBody = e.body;
    } else if (e instanceof Error) {
      errorTitle = 'Unexpected error';
      errorMessage = ponyCause.messageWithCauses(e);
      errorBody = ponyCause.stackWithCauses(e);
    } else {
      errorTitle = 'Unexpected error with no details';
    }
    console.error(`${npmPaths.getLogSymbols().error} ${colors.bgRed(colors.white(errorTitle + ':'))} ${errorMessage}`);
    if (errorBody) {
      console.error(`\n${errorBody}`);
    }
    await index.captureException(e);
  }
})();
//# debugId=a4acc1e3-c084-4a1d-93c2-9d46f8d72142
//# sourceMappingURL=cli.js.map
